
[{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/blog/","section":"Tags","summary":"","title":"Blog","type":"tags"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/pop_a_calc/","section":"Tags","summary":"","title":"Pop_a_calc","type":"tags"},{"content":" Writing the Shellcode x86 W32 # 32 bit also goes through the same steps as 64 bits so I woudn\u0026rsquo;t be explaining it in detail rather, I have commented it on the side for you to understand and pick up based on context from x64\nxor eax, eax\rxor ebx, ebx\rmov ebx, [fs:ebx + 0x030] ; PEB loaded in eax\rmov ebx, [ebx + 0x0c] ; Address of PEB_LDR_Module is loaded (in 32 bit it is at offset 0c)\rmov ebx, [ebx + 0x14] ; Address of InMemoryOrderModuleList is loaded this is pointing to kernelbase.dll\rmov ebx, [ebx] ; Pointing to ntdll\u0026#39;s ldr_data_table_entry\rmov ebx, [ebx] ; Pointing to kernel32.dll\u0026#39;s ldr_data_table_entry\rmov ebx, [ebx + 0x10] ; Base Address of kernel32.dll is now loaded\r;--------------Base address of kernel32dll is now loaded into ebx------------------\rpush ebp ; Storing prev stack base\rmov ebp, esp ; Setting up the base of new stack\rsub esp, 18h ; Setting up the new stack frame (to accomodate for the lack of registers in x64)\rxor esi, esi ; Clearing out esi manually\rpush esi ; To fix the alignment on the stack\rpush 00636578h ; \u0026#34;\\00cex\u0026#34; is being pushed onto the stack\rpush 456e6957h ; \u0026#34;EniW\u0026#34; is being pushed onto the stack\rmov [ebp-4], esp ; WinExec\\x00\rmov eax, [ebx + 3Ch] ; RVA of PE signature\radd eax, ebx ; Address of PE signature = base address + RVA of PE Signature\rmov eax, [eax + 78h] ; RVA of Export Table Directory\radd eax, ebx ; Address of Export Table Directory = base address + RVA of Export Table Directory\rmov [ebp-08h], eax ; Address of Export Table direcorty is being moved into ebp-0x8 for future purposes mov ecx, [eax + 24h] ; RVA of Ordinal Table\radd ecx, ebx ; Address of Ordinal Table = base address + RVA of Ordinal Table\rmov [ebp-0Ch], ecx ; Address of Ordinal Table is being moved into ebp-0xC\rmov edi, [eax + 20h] ; RVA of Name Pointer Table\radd edi, ebx ; Address of Name Pointer Table\rmov [ebp-10h], edi ; Address of Name Pointer Table is being moved into ebp-0x10\rmov edx, [eax + 1Ch] ; RVA of Export Address Table\radd edx, ebx ; Address of Export Address Table\rmov [ebp-14h], edx ; Address of Export Address Table is being moved into ebp-0x14\rmov edx, [eax + 14h] ; Number of exported functions is taken at the offset of 0x14 from eax, eax holds the Address of the Export Table Directory\rxor ecx, ecx ; ecx is cleared\rmov ecx, 0x7 ; ecx is loaded with the length of \u0026#34;WinExec\u0026#34;\rdynamic_api_resolve:\rmov edx, esp ; The last thing we pushed onto the stack was WinExec since which esp has not been changed, so it\u0026#39;s address is loaded into edx\rpush ecx\rxor eax, eax ; eax is cleared to be used as counter\rloop:\rmov ecx, [esp] ; Value at esp \u0026#34;WinExec\u0026#34; is loaded into ecx\rxor edi, edi ; edi is cleared\rmov edi, [ebp - 10h] ; Name pointer Table\u0026#39;s address is being moved into edi\rmov edi, [edi + eax * 4] ; Each entry inside the name pointer table (RVA of the symbol names) are being loaded one by one into edi\radd edi,ebx ; Actual Address of the symbol name = RVA of symbol name + base address\rmov esi,edx ; edx containing the address to string \u0026#34;WinExec\u0026#34; is moved into esi\rrepe cmpsb ; Used to compare strings stored in esi with strings stored in edi byte by byte je get_addr ; If it is equal we get the actual address of the function\rinc eax ; If not we increment the counte\rjmp loop ; Go back to loop in search for the next symbol name\rget_addr: xor ecx, ecx ; ecx is cleared\rmov ecx,[ebp-0Ch] ; Address of Ordinal Table is being loaded from ebp-0xC\rmov ax,[ecx + eax * 2] ; Same counter eax is taken and multiplied by 2 to account for words(as that is how ordinal table is maintained) and it\u0026#39;s added with address of Ordinal Table. This Ordinal Value is stored in ax\rxor ecx, ecx ; ecx is cleared\rmov ecx, [ebp - 14h] ; Address of Export Address Table is loaded into ecx\rmov eax, [ecx + eax * 4] ; And that is now being added with 4 * Ordinal value of the function to get the RVA address of the WinExec function into eax\radd eax, ebx ; Address of the WinExec API = RVA of WinExec + base address xor esi, esi ; esi is cleared\rpush esi ; being pushed onto stack for stakc alignment xor ecx, ecx ; clear ecx register\rpush ecx ; string terminator 0x00 for \u0026#34;calc.exe\u0026#34; string\rpush 0x6578652e ; exe. : 6578652e\rpush 0x636c6163 ; clac : 636c6163\rmov ebx, esp ; save pointer to \u0026#34;calc.exe\u0026#34; string in eax\rinc ecx ; SW_SHOWNORMAL = 0x00000001 is being set\rpush ecx ; tha is being pushed as the second argument\rpush ebx ; Calc.exe is being pushed as the first argument\rcall eax ; WinExec(\u0026#39;calc.exe\u0026#39;, 0x1) is called. Compiling 32 bit # Source # x86 Assembly to pop a calculator\nAssemble # To compile the shellcode and get the object file we can use any assembler, I prefer nasm:\nnasm -f win32 pop_calc_32.asm -o pop_calc_32.o Get Payload bytes # This is not necessary to just compile and run the shellcode. But, assuming we want to use this as payload, this is the one-liner used to generate the instruction bytes\nfor i in $(objdump -D pop_calc_32.o | grep \u0026#34;^ \u0026#34; | cut -f2); do echo -n \u0026#34;\\x$i\u0026#34; ; done Link # Before running this shellcode as such we would requrire linking, which can be done by\nld -m i386pe pop_calc_32.o -o pop_calc_32.exe To Run # pop_calc_32.exe Exit() # That brings us to the end of this blog post. To know more about where to look into how to load shellcode feel free to check out the loading payloads blog.\n","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/series1_pop_a_calc_part_3/","section":"Welcome to Posts!","summary":"Writing the Shellcode x86 W32 # 32 bit also goes through the same steps as 64 bits so I woudn\u0026rsquo;t be explaining it in detail rather, I have commented it on the side for you to understand and pick up based on context from x64","title":"Popping a calculator - 32 bit - Part 3/3","type":"posts"},{"content":" Writing the Shellcode x64 # This part of the blog covers the 64 bit shellcode to pop a calculator. Here I would be explaining my approach at writing source, you can skip right down to the bottom if you just want the compilation information here\nFor the source code you can visit the github repo\nGet The Kernel Base Address # This is the assembly that I ended up writing to get the kernel32 base\nxor rax, rax\rxor rcx, rcx\rmov rcx, gs:[rax + 0x60] ; Address of PEB is loaded\rmov rcx, [rcx+0x18] ; Address of PEB_LDR_Module is loaded\rmov rcx, [rcx+0x20] ; Address of InMemoryOrderModuleList is loaded this is pointing to kernelbase.dll\rmov rcx, [rcx+ 0x00] ; Pointing to ntdll\u0026#39;s ldr_data_table_entry\rmov rcx, [rcx + 0x00] ; kernel32.dll\u0026#39;s ldr_data_table_entry is now referenced\rmov rcx, [rcx+0x20] ; base Address of kernel32.dll is now loaded\rmov r10, rcx ; r10 and rcx have kernel32 base Now looking at this it might not be that comprehensible, so I\u0026rsquo;ll try my best to explain it in the simplest terms\nLine 1 \u0026amp; 2 - Are pretty obvious we are zero\u0026rsquo;ing out the rax and rcx registers\nLine 3 - We load the PEB base address using the offset from the gs register into rcx\nFor the people that are familiar with basic windows internals you might be familiar with the gs register. For the ones new to WinRev\nWhat is gs and fs?\nIn earlier days of computing, there was a need for segment registers like some of which you might have heard of like cs(code segment) es(extra segment),ss(stack segment) ,ds(data segment) etc.\nThese registers were born out of necessity to keep track of these segments and hold their addresses back when memory paging wasn\u0026rsquo;t introduced to manage memory.\nSo they used to keep these registers as base for segments and continue referencing memory at particular offsets from these registers to refer to various resources and code in appropriate sections.\nBut when memory paging came by the need for these registers were obsolete, and yet they are still present in Intel Architecture purely for backwards compatibility reasons and are still supported in different forms.\nWindows specifically uses a few segment registers like fs and gs to keep track of certain important structures related to a process like the PEB and TEB.\nYou can read up more on PEB and TEB on the internet But in simple words let\u0026rsquo;s look at some\nSome important Windows Data Structures (TIB/PEB/TEB) # TIB - Thread Information Block - was used for the non WindowsNT versions, to hold basic process information. Widnows still supports it for backwards compatibilty reasons.\nPEB - Process Environment Block - The Process Environment Block structure contains the process wide data structures which include global context, startup parameters, data structures for the program image loader, the program image base address, and synchronization objects\nTEB - Thread Environment Block - Is an extentsion of the TIB and hence TEB and TIB are used synonymously. The TEB is the structure for Windows NT, 2000, XP, Vista, 7, 8, 10 and 11.\nIn 32 bit, the fs register is used and this is used to point to the TIB of a given thread These are the structure offsets inside TIB at which we can find various other important structural fields\nFS:[0x00] : Current SEH Frame FS:[0x18] : TEB (Thread Environment Block) FS:[0x20] : PID FS:[0x24] : TID FS:[0x30] : PEB (Process Environment Block) FS:[0x34] : Last Error Value\nIn 64 bit, the gs regsiter is used in place of fs to keep track of the TIB structure\nGS:[0x30] : TEB GS:[0x40] : PID GS:[0x48] : TID GS:[0x60] : PEB\nNow using these registers and offset we can find our way into the PEB of any given windows binary.\nLine 4 - Now rcx which holds the base to PEB is added with 0x18 to get to the offset of PEB_LDR_DATA\nAbout PEB and PEB_LDR_DATA structure\nPEB Structure\nAs mentioned easlier, the PEB structure contains various information about a particular process like the base address, if it is being debugged or not, any inherited flags from other parent processes etc.\nSource\nBut the one we are most interested in is the PEB_LDR_DATA.\nThe PEB_LDR_DATA structure is the defining record of which user-mode modules are loaded in a process. Each process has one PEB_LDR_DATA structure associated with it. Its address is kept in the Ldr member of the process‚Äôs PEB. PEB_LDR_STRUCTURE\ntypedef struct _PEB_LDR_DATA\r{\rULONG Length;\rUCHAR Initialized;\rPVOID SsHandle;\rLIST_ENTRY InLoadOrderModuleList;\rLIST_ENTRY InMemoryOrderModuleList;\rLIST_ENTRY InInitializationOrderModuleList;\rPVOID EntryInProgress;\r} PEB_LDR_DATA, *PPEB_LDR_DATA; As you can see it contains pointers to three important linked lists\nNamely,\nInLoadOrderModuleList InMemoryOrderModuleList InInitializationOrderModuleList They hold information about the modules (dlls) that are loaded by a proces\nThese are linked lists which share the same elements but they are just linked in a different order as suggested by their names\nTo explain them in brief I shall site it from a book -\nSource - The art of memory forensics book\nInLoadOrderModuleList - This linked list organizes modules in the order in which they are loaded into a process. Because the process executable is alwyas first to load in the process address space, its entry is first in this list.\nInMemoryOrderModuleList - This linked list organizes modules in the order in which they appear in the process\u0026rsquo;s virtual memory layout. The last DLL to load may end up first in memory due to ASLR and other factors\nInIntializationOrderModuleList - This linked list organizes the modules in the order in which their DLL Main was executed. Just because a dll in loaded doesn\u0026rsquo;t mean the DllMain is always called. For example, when we load a dll as a data file or as a resource.\nLine 5 - Now The address to the First Link of the linked list of InMemoryOrderModuleList is loaded.\nThe offset is at 0x20 for 64 bit\nThe first link is pointing to an entry about Kernelbase.dll, so at the offset 0x20 we have LDR_TABLE_ENTRY structure Why InMemoryOrderModuleList?\nWell, In all windows versions, the second and third DLLs in the linked list of InMemoryOrderModuleList is always ntdll.dll and kernel32.dll.\nWe can also accomplish this using InLoadOrderModuleList however, the order of DLLs were changed from Vista onwards, so this doesn\u0026rsquo;t ensure portability of shellcode.\nHence we stick with InMemoryOrderModuleList\nNow after executing line 5 rcx points to the LDR_DATA_TABLE_ENTRY of kernelbase.dll\nLine 6 - Now we load the address of the second entry into the rcx , which now holds the base to ntdll (as the first entry was already kernelbase.dll and it was pointed to by)\nLDR_TABLE_DATA_STRUCTURE\nThe way it works is as depicted below\nSource\nBecause we started accessing from the InMemoryOrderModuleList it keeps pointing to the next InMemoryOrderModuleList entry in the LDR_DATA_TABLE_ENTRY structure. Hence we are able to retrieve ntdll\u0026rsquo;s LDR_DATA_TABLE_ENTRY structure by just calling offset 0\nLINE 7 - Similar to line 6 we now load the next dll (ie) the third dll in memory order.\nLINE 8 - Now we load the base of kernel32.dll at offset 0x20\nNow you may wonder, why is it at 0x20 and not 0x30 as shown in the LDR_DATA_TABLE_ENTRY structure above\nThat because of the very reason mentioned earlier, even though we got to the kernel32.dll\u0026rsquo;s LDR_DATA_TABLE_ENTRY by calling offset-0x00 , we used a pointer to the LIST_ENTRY InMemoryOrderLinks and not to the start of the structure.\nNow to acess the DLL Base we need to find the relative offset from The InMemoryOrderLinks entry. Which ends up being 0x30 - 0x10 = 0x20\nSo now rcx and r10 holds the base address of the kernel32.dll\nLine 9 - It just copies the value inside rcx into r10 for future uses\nGet the address to the Export table # mov ecx, [rcx + 0x3c] ; Find RVA to PE header\radd rcx, r10 ; Points to the PE header\r;mov rcx, [rcx + 0x78] ; RVA of Export table directory\rmov ecx, [rcx + 0x88] ; RVA of Export table directory\radd rcx, r10 ; Export table directory address loaded\rxor r9, r9\rmov r9d, [rcx + 0x1c] ; RVA Export Address Table\radd r9, r10 ; Address to export Address Table\rxor r11, r11\rmov r11d, [rcx + 0x20] ; RVA Export Name pointer table address add r11, r10 ; Adrdess of Export Name pointer table xor r12, r12 mov r12d, [rcx + 0x24] ; RVA of Ordinal Table\radd r12, r10 ; Address of Ordinal Table Here Initially rcx and r10 hold the base of the kernel32 dll\nLine 1 - Here we find the RVA (Relative virtual address from the base of Kernel32), to the the PE Header The offset of 0x3c is never changed and remains the same in the PE format, as it is used to get to the PE header.\nEnough being side tracked, but as you can see in the image, the letter PE show up at the RVA 0xE8 and the offset/the RVA of this can always be found at 0x3C from the base.\nLine 2 - Now we just add this offset (in our case E8) to the base of kernel32 dll to get the pointer to the PE header\nLine 3 \u0026amp; 4 - You may notice that line 3 is commented out and it has been given the same comment as RVA of Export Table Directory as similar to line 4. Now I don\u0026rsquo;t know the reason why, but in our case when I used tools such as PE VIEW and CFF Explorer both the tools showed the offset to find the RVA(Relative virtual address from the base of the dll) for Export Table Directory as 0x88 from the PE header.\nBut, in the countless blogs that I did refer to and did take notes from as I was researching on shellcode and how it works, and many other windows related blogs all of them mention the RVA to be found at the offset 0x78 and not at 0x88.\nSo if someone kind enough to know the reason behind this is out there, feel free contact me and help me understand this üò≠üò≠ and I\u0026rsquo;ll edit this blog and put out the explanation as well.\nBut yes, that being said, the RVA for kernel32.dll\u0026rsquo;s in this particular case is at the offset 0x88 from the PE header, so rn we load that and move it into ecx and add it with r10 the kernel32.dll\u0026rsquo;s base address.\nLine 5 - Next we need to find the Export Table Address. Now you may wonder why is there a need for Export Table Directory and Export Table as two separate things. Why couldn\u0026rsquo;t we just have the Export Table as a single entity so that we could just take the address refering to the name directly.\nWell, the way windows has organized is not just a simple Export Table rather, it\u0026rsquo;s a well defined structure that has general information with regards to exports furthermore it has three important table pointers pertaining to the sole purpose of keeping track of what all functions and modules are being exported out of a binary.\nsource: Export Address Table (EAT)\nExport Address Table pointer It contains the RVA to the list of exported functions. And an associated ord value. The ord value can be used to find the RVA of the exported function Name Pointer Table It contains the names of the exported functions and associated address of this name string in memory. This table can be parsed to find the address to a particular function\u0026rsquo;s address Ordinal Table It contains the address of the various symbols and an associated ordinal value So, these 3 tables are interconnected and are needed for a succesful retreival of an exported function\u0026rsquo;s address.\nLine 6, 7 and 8 - Now we get the register r9 that is going to hold the address of the Export Address Table ready. And the RVA(Relative Virtual Address from the base of the kernel32.dll) to the export address table at an offset of 0x1c from the address of Export table directory.This RVA is always a dword hence we stored it under r9d. And finally we add this RVA to the base of kernel32.dll to get the address to Export Address Table.\nLine 9, 10 and 11 - Now we get the register r11 that is going to hold the address of the ready. And the RVA(Relative Virtual Address from the base of the kernel32.dll) to the Name Pointer Table at an offset of 0x20 from the address of Export table directory. This RVA is always a dword hence we stored it under r11d.And finally we add this RVA to the base of kernel32.dll to get the address to Name pointer table.\nLine 12, 13 and 14 - Now we get the register r12 that is going to hold the address of the ready. And the RVA(Relative Virtual Address from the base of the kernel32.dll) to the Ordinal Table at an offset of 0x24 from the address of Export table directory. This RVA is always a dword hence we stored it under r12d.And finally we add this RVA to the base of kernel32.dll to get the address to Ordinal Table.\nSummary of registers so far:\nr10 - Holds kernel32.dll\u0026rsquo;s base r9 - Holds the Export Address Table pointer r11 - Holds Name Pointer Table Address r12 - Holds Ordinal Table Address\nFind the Base address of the WinExec function # xor rcx, rcx ; rcx is cleared\rmov rcx, 0x7 ; Length of WinExec is loaded into rcx\rmov rax, 0x00636578456e6957 ; \u0026#34;\\00cexEniW\u0026#34; is loaded into rax\rpush rax ; The string name is pushed onto the stack\rpush rcx ; Length is pushed onto the stack\rcall dynamic_api_resolve ; dynamic_api_resolve label is called\rmov r14, rax ; return address of the WinExec is put into r14\rjmp next ; we jump to the next label\rdynamic_api_resolve:\rpop rbx ; return address is stored in rbx\rpop rcx ; Length of the api is stored into rcx\rxor rax, rax ; rax is cleared\rmov rdx, rsp ; Move the address of name of the api into rdx\rpush rcx ; Length of the api is pushed onto the stack\rloop:\rmov rcx, [rsp] ; The counter is being refreshed each time\rxor rdi, rdi ; clear rdi for getting the name\rmov edi, [r11 + rax * 4] ; RVA of function name symbol = Address of Name Pointer Table + counter * 4\radd rdi, r10 ; Address of Function name symbol = RVA of function name symbol + base address mov rsi, rdx ; moving string to be compared into rsi\rrepe cmpsb ; comparing strings in rdi and rsi\rje get_addr ; If equal we jump to get the address\rinc rax ; Else increment counter\rjmp loop ; jump back into loop\rget_addr:\rpop rcx ; Remove string length from top of stack\rmov ax, [r12 + rax * 2] ; Ordinal number of kernel 32 API (WinExec) = Adress of ordinal table + Counter * 2\rmov eax, [r9 + rax * 4] ; RVA of API = Address of Export Address Table + Ordinal number of WinExec * 4\radd rax, r10 ; Address of the API = RVA of API + base address\rpush rbx ; Pushing the Return Address back onto the stack\rret Line 1 \u0026amp; 2 - We start off with clearing out rcx register and set it to be 0x7 which is len(\u0026quot;WinExec\u0026quot;)\nLine 3 - It\u0026rsquo;s \u0026quot;WinExec\\00\u0026quot; in little endian moved into rax\nLine 5, 6 \u0026amp; 7 - Now we push the \u0026quot;WinExec\\00\u0026quot; first followed by the length and call our dynamic_api_resolve label\nContinuing with the control flow,\nLine 11 - We initially store the return address at the top of the stack and store it in rbx.\nLine 12 - 15 - Next value on top of the stack is the length that we pushed. That is being stored back in rcx, then rax is cleared. Now that the length is popped, the value at rsp (ie the top of the stack) is now the string of 'WinExec'. The address of rsp is put into rdx, and rcx is pushed back onto the stack.\nLine 17: Defines the start of a label which is used to loop\nLine 19 - 23 : We move the counter into rcx. Clear rdi for future purposes.Now remember, r11 holds the Address of the Name Pointer Table.\nSo, we add Address of Name pointer table + a counter (this we are mainting to keep track of which index of the Name pointer table is the symbol of our WinExec function at)\nAnd this counter is multiplied by 4 because all the RVA values inside this function is stored in dword format.\nSo, right now we load the RVA of the string into edi, and adding the kernel32 base to get the address of the actual string. We keep this arbitrary string in rdi.\nrdx had our \u0026quot;WinExec\u0026quot; whose address is now being moved into rsi\nLine 25 - 28 - repe cmpsb is executed. Now this is a instruction which compares the string values inside rdi and rsi and sets the zero flag accordingly. It compares it byte by byte, but it\u0026rsquo;s all masked under the single instruction of repe cmpsb.\nNow if the strings are equal then we go ahead and jump to get_addr. Which we\u0026rsquo;ll get to in a bit. But if it is not equal then we increment the counter value by 1, to go to the next RVA of the next string. And we jump back to loop ie (line 17)\nLine 31 - 33 - label get_addr is defined. Now as we know, the top of the stack contains the length of the string \u0026quot;WinExec\u0026quot;. We pop this from the top of the stack back into rcx.\nNow we need to find the ordinal number of the particular WinExec. And ordinal number is simply put an index that windows maintains for each and every export.\nThink of it as a process ID but for exported functions. Each exported function has a unique ID which windows uses to reference the respective functions. And this ordinal number is stored as a WORD. Like so,\nThe names might look too confusing, but as of now just focus on Name RVA and it\u0026rsquo;s type as shown below in the image, Name Ordinal and it\u0026rsquo;s type and Function RVA and it\u0026rsquo;s type in the image\nSo the ordinal numbers are arranged in order as you can see, and a corresponding ordinal number can be found out using the corresponding counter variable.\nBecause we kept track of rax, the index of the RVA of the function, now we can find the ordinal numebr using the same rax counter.\nAll we have to do is just take this counter/index and multiply it by 2 because of WORD and then add it to the base address of the orindal table.\nNow derefencing this calculated pointer would get us the ordinal number of the appropriate name string. Because ordinal numbers are stored as words, we stored it back in ax\nLine 35 - 38 - Now we take this ordinal number and multiply it by 4 (Function RVA is stored as DWORD) and add this to the base of the Export Address Table to get the function RVA of our desired function which is \u0026quot;WinExec\u0026quot;\nWe now take this RVA and add it with r10(the kernel32.dll\u0026rsquo;s) base address to finally get the address of the desired API and store it under the rax register. (The return value of any call function is stored under rax). Now we push the rbx(the register that held on to the return address) and execute ret.\nExecuting ret would take us back to\nLine 7 \u0026amp; 8 - Now address of the WinExec function inside rax is moved into the r14 register and we now jump to a label called next\nLoad the arguments into the WinExec function # ;------------------------now r14 has our API -----------------------------------\rnext:\rxor rcx, rcx ; clears out rcx mul rcx ; rax, rdx and rcx are 0\rpush rax ; Null Terminate string on stack\rmov rax, 0x6578652e636c6163 ; Moving \u0026#34;exe.clac\u0026#34; into rax\rpush rax\rmov rcx, rsp ; into first argument\rinc rdx ; Argument to winEXe show_Normal For this part we shall refer to the msdn documention on WinExec\nAnd as we,\nWe need to give\nthe cmdline string of the program that we want to run The cmdshow argument (this is basically controls how to open the program in what typ eof window) We shall still with just the most basic show_window_normal which holds the value 1 as it can be seen here. Line 1 - 3 - We now reach the next label. rcx is cleared and we use mul rcx to also clear rax, rdx as well\nLine 5 - 7 - Now that rax is 0, we just push it onto the stack to act as a null terminator for the upcoming string that we are about to push.\nThen we mov 0x6578652e636c6163 which is calc.exe in little endian. Now we push it onto the stack as well\nThen we load the first argument into rcx, which is at the top of the stack. The windows calling convention goes like rcx, rdx, r8, r9 .\nNow we increment that value of rdx by 1, setting 1 as the second argument.\nCall the function # sub rsp, 0x20\rcall r14 Here we do sub rsp, 0x20. Because I learnt WinExec clobbers the first 32 bytes on the stack as it is a function that is only to be in use for 16 bit mode and any system running in either 32 or 64 bit mode should use CreateProcess as mentioned in the above image. So this extra space that we create acts as a safety net to prevent it from clobbering our useful bytes.\nNow we go ahead and call r14 which holds the address of WinExec.\nThat brings us to the end of our x64 shellcode.\nCompiling 64 bit # Source Code # The full source and the associated files for this can be found here on my github - x64 Assembly to pop a calculator\nAssemble # To compile the shellcode and get the object file we can use any assembler, I prefer nasm:\nnasm -f win64 pop_calc.asm -o pop_calc.o Get Payload bytes # This is not necessary to just compile and run the shellcode. But, assuming we want to use this as payload, this is the one-liner used to generate the instruction bytes\nfor i in $(objdump -D pop_calc.o | grep \u0026#34;^ \u0026#34; | cut -f2); do echo -n \u0026#34;\\x$i\u0026#34; ; done Link # Before running this shellcode as such we would requrire linking, which can be done by\nld -m i386pep pop_calc.o -o pop_calc.exe To Run # pop_calc.exe ","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/series1_pop_a_calc_part_2/","section":"Welcome to Posts!","summary":"Writing the Shellcode x64 # This part of the blog covers the 64 bit shellcode to pop a calculator.","title":"Popping a calculator - 64 bit - Part 2/3","type":"posts"},{"content":" Windows Shellcoding Series 1 - Part 1/3 # Popping a calculator # Init() # Now in the series I would be covering both the 64 bit and 32 bit versions of the shellcode to pop a calculator and would go about explaining them both separately.\nThe Approach # The basic idea of approach or the methodology in which I intend to approach writing this shellcode is the same for both 64 bit and 32 bit.\nNow let\u0026rsquo;s start by thinking backwards from the result as to figure out what we need in the shellcode to launch the calculator.\n- Execute a calculator # The end goal of our current shellcode is that it needs to end in launching a calculator For the exact purpose of executing/launching applications windows has the WinExec API which does exactly what we need\nsource : MSDN WinExec Documentation\nSo all we need to do is call WinExec with it\u0026rsquo;s required parameters and we\u0026rsquo;re done. We could have also done it using CreateProcessA but that involves a lot more arguments and I wanted to use the most simplest approach to this shellcode But, now this gets us thinking how do we go about calling WinExec?ü§î\n- How to call WinExec? # If we are normally programming we can just do a WinExec() with the necessary arguments\nHowever, internally in assembly we do a call register where the register holds the addresss of the function that we are about to call\nSo in a nutshell, To call any function we need an address An address to where this function is defined and loaded in memory\nSo first we need to figure out where this WinExec Function is defined inside the system.\nNow upon basic googling we find kernel32.dll to contain the function definition of WinExec .\nSo now we need to go about finding where exactly inside kernel32 is this function Winexec defined\n- Finding WinExec inside kernel32 # So now to get down to a few Windows Reversing basics, All windows executables need to follow the PE format which defines how a particular executable is to organize it\u0026rsquo;s various data, like code, images, functions that it imports from other executables or libaries so on and so forth.\nSo, any windows executable (PE format) contains a lot of sections out of which two important ones are the Export Table and Import table\nThese two tables store the information relating to the modules that are being imported by the binary and exported from the binary\nIn our case we need to look for WinExec inside kernel32.dll under the Export Directory, because whatever is being exported out of a dll is stored under the Export Directory.\nThis Export directory would contain information like the name of the corresponding function (WinExec in our case) and the offset where we can find it\nSo summarising what we need to do now is\nto find the base address to the kernel32.dll function then from there we can get to the Export Address Directory inside kernel32.dll then next we can get to the base address of the function WinExec - Getting base of kernel32.dll # Windows creates/launches a thread to run any code, even the arbitrary bytes such as this shellcode. And while doing so, it also associates a very important data structure to each thread that it runs and controls called the TEB - The Thread Environment Block. This structure holds important information pertaining to a thread and the libraries/dlls it loads. This TEB also points to another important strcuture associated to any such process and thread called the PEB - Process Environment Block which is maintained at a constant offset from the TEB. Using this PEB now we can find the base address of the kernel32.dll\nNow this might be a bit confusing to the new ones here, the questions probably running through your mind is,\nSure, there\u0026rsquo;s a TEB associated to every running thread and running a thread is how windows runs the shellcode. But what I don\u0026rsquo;t get is,\nWhy is this associated to kernel32.dll which has nothing to do with the shellcode as of yet? Why is it already associated with our shellcode without us even having to load this particular library/dll? Why is it already associated without even having to call any function from it previously? Well to answer that, let\u0026rsquo;s take a step back and look at three important dlls in Windows that are crucial to the functioning of the Operating system by itself\nntdll.dll kernel32.dll KERNELBASE.dll These dlls contain a lot of functions that are crucial to the very basic functioning of the Operating system itself and is constantly being accessed by multiple user processes and even windows internal processes to keep the operating system functioning and alive. Windows\u0026rsquo;s own processes make use of various functions from these dlls to even start up the OS by itself. For example, The base services (like working with file systems, processes, devices, etc.) are provided by kernel32.dll.\nSo I hope the importance of these dlls in the Windows operating system established now.\nAnd because these dll\u0026rsquo;s are commonly used and loaded, it would make a lot more sense to just load them into the memory once at system start and then pass handles (or) pointers as reference to other processes which require functions from these dlls.\nWhich is exactly what happens and why it is already associated in a process\u0026rsquo;s TEB-\u0026gt;PEB by default.\nAnd because these dlls are very important they are by default imported by each and every thread/process because it is required to even start up the thread in the first place. Especially ntdll.dll and kernel32.dll\nTo summarise, we can find the kernel32.dll\u0026rsquo;s base through the TEB associated with our shellcode thread because it is already imported when the OS runs the shellcode.\nSo now we know where we can find these dll\u0026rsquo;s being loaded and under what data structure can we find them. The how is explained in this series.\n- Compiling and running the shellcode # Loading the shellcode can be done by the help of a simple dropper program which carries our payload (shellcode) and runs it on the fly. This method is covered in my other blog post which you can find here\nSo now that we have the approach down This is the final skeletal steps of our approach to write our shellcode\n1) Get the kernel base address\r2) Get the address to the Export table\r3) Find the Base address of the WinExec function\r4) Load the arguments into the WinExec function\r5) Call the function\r6) Compiling the shellcode These 6 steps are going to be out outline for the writing the shellcode\nWe\u0026rsquo;ll look into 64 bit shellcode in the next Part of this blog post.\n","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/series1_pop_a_calc_part_1/","section":"Welcome to Posts!","summary":"Windows Shellcoding Series 1 - Part 1/3 # Popping a calculator # Init() # Now in the series I would be covering both the 64 bit and 32 bit versions of the shellcode to pop a calculator and would go about explaining them both separately.","title":"Popping a calculator - Basic - Part 1/3","type":"posts"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/","section":"retr0ds_blog","summary":"","title":"retr0ds_blog","type":"page"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/categories/reversing/","section":"Categories","summary":"","title":"Reversing","type":"categories"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/series/","section":"Tags","summary":"","title":"Series","type":"tags"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/shellcode/","section":"Tags","summary":"","title":"Shellcode","type":"tags"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/series/shellcoding/","section":"Series","summary":"","title":"Shellcoding","type":"series"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/","section":"Welcome to Posts!","summary":"Learn more about me and why I am starting this blog.","title":"Shellcoding series","type":"posts"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Contains all my posts organized year wise\n","date":"27 March 2024","externalUrl":null,"permalink":"/posts/","section":"Welcome to Posts!","summary":"Learn more about me and why I am starting this blog.","title":"Welcome to Posts!","type":"posts"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/windows/","section":"Tags","summary":"","title":"Windows","type":"tags"},{"content":" Windows Shellcoding Series 0 # Init() # Welcome to the prequel blogpost of my Shellcoding Series With this I intend to start of a series of Shellcoding based blogposts aiming to develop and post interesting shellcodes\nThe pre-requisite to follow this series of blog posts:\nA laptop ofc Bad social life (Why else would you be on here?) An omnitirix (Everyone has one these days) The Hardcover Windows internals book by Pavel Yosifovich 7th edition (to place your laptop on for good ergonomics) The Why? # I have always been fascinated by shellcode (especially in windows) and the intricacies it holds.\nStriving to create a nulbyte free shellcode, limiting the shellcode to under a certain size are some of the intricacies that we\u0026rsquo;ll get into as well\nThe idea of being able to use a set of bytes as a payload to inject into memory and to execute it has always seemed fun to me.\nSo I thought the best way to learn shellcoding is to make a blog series out of it as I experiment my way through shellcode and windows internals . And I hope to learn a lot out of this journey while being able to share to the community as well.\nWell, without further ado, let\u0026rsquo;s jump right into the topic!\nWhat is Shellcode? # Simply put, a piece of shellcode is a set of bytes(of assembly instructions) that can be loaded in memory and executed like any other piece of assembly code.\nA shellcode is a versatile piece of code that allows us to dynamically load a block of assembly instructions and execute it on the fly thereby enhancing the capabilities of a binary. It is particularly useful for malicious purposes, when combined with an encrypter or a packer it can go undetected under various EDRs and other AV scanners and checkers.\nFor example\nchar shellcode[] = \u0026#34;\\x90\\x90\\xcc\\xc3\u0026#34; \\x90 is for NOP \\xcc is for INT3 \\xc3 is for RET\nThis payload/shellode translates to\nNOP\rNOP\rINT3\rRET And this shellcode can be loaded into memory and executed like any other section of assembly code\nWe\u0026rsquo;ll be covering the loading of shellcode in the other blogposts of mine\nWhat does it accomplish? # Now clearly the above shown shellcode doesn\u0026rsquo;t accomplish much\nThere\u0026rsquo;s much more powerful and useful shellcode harboring malicious intent such as connecting to a c2 server and downloading the actual malicious file, dll injection, processs injection and many more.\nThere\u0026rsquo;s a pretty neat interface to get working shellcode for this purpose on windows\nMsfVenom # MsfVenom is a shellcode generator that has templates based upon which we can customize our own payload\nNow this series doesn\u0026rsquo;t cover shellcode generation by MsfVenom, Metasploit has a pretty neat documentation for that. Feel free to check that out.\nAbout this series # Now this series aims to showcase various shellcode/payload for various purposes on windows and aims to completely write it from scratch and in the process also learn a lot about Windows Internals, it\u0026rsquo;s structures, APIs and techniques\nThis series would mostly look like a walkthrough rather than a research blog, because it is being written as I am exploring around in windows internals and red teaming as well.\nExit() # With all that being said, now let\u0026rsquo;s get down to business and let\u0026rsquo;s write some basic windows shellcode begining with the next blog post.\n","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/series0_basic/","section":"Welcome to Posts!","summary":"Windows Shellcoding Series 0 # Init() # Welcome to the prequel blogpost of my Shellcoding Series With this I intend to start of a series of Shellcoding based blogposts aiming to develop and post interesting shellcodes","title":"Windows Shellcoding Series 0","type":"posts"},{"content":"tl;dr\nChallenge 2 of Batman Investigation series Ransomware Investigation Rust based Ransomware Analysis with process dump analysis to recover the randomly generated decryption vector and windows malware analysis Recovering from a ransomware attack Challenge Points: 1000 No. of solves: 1 Challenge Author: Azr43lKn1ght\nChallenge Description: # Azrael the Archangel of Vengeance has joined the batfamily after destroying the machine of St Dumas defeating face to face against his most startling foe, the undying heirophant, the first son of St Dumas. The Dumas is not completely destroyed and the heirarchy out somewhere out, Jean Paul, our Azrael has a shared workspace with Duke Thomas, The signal. St Dumas got them now by sending the weapon of azrael but we got the attack process captured by signal as he was the one who let it in unknowingly. Azrael and Signal are trying to fix things to get back whatever is lost as well not get in the clutches of the order. They should now have to safegaurd batman\u0026rsquo;s files as well as their own important ones. if they get it back before Dumas knowing they are getting close to finding them to stop the order as well the birth and training of new Azraels when they are waiting for negotiation or some plan to take our protagonists with hold of the recovery shard. Can you help them to recover from the loses and find the weapon of Azrael ,so they can take down the order of the St Dumas?\nFile Password : E6qK~$9pUIk0kT'3\u0026amp;N/Okt\nChallenge Files:\nPrimary Link Mirror Link nc link Flag format: bi0sctf{...} # We\u0026rsquo;ll be starting with question 5 of the challenge cuz that\u0026rsquo;s where the real reversing comes in, so the quesiton 5 is as follows\nQuestion 5 # Q5) What is the ip and port the malware is sending the decryption essential to? Format: ip:port\nso first let\u0026rsquo;s start analysing the mssetup.exe file.\nusing detect it easy we can see that it is packed with upx, let\u0026rsquo;s unpack it\nnow let\u0026rsquo;s check again\nnow it is pretty normal with sections and imports being normal, so we can start static analysis.\nTriaging # Running file on the binary shows it‚Äôs a 64 bit PE executable We open the binary in Detect_it_easy, And we can clearly see it is a UPX packed binary, meaning we would have to unpack it first\nCan be done using\nupx -d mssetup.exe\nNow the unpacked binary when put through DIE seems to be normal trying strings on it we see a few intersting strings such as A ransom note looking text 98238588864125956469313398338937 Azr43l_README.txt C:\\Windows\\System32\\winevt\\Logs C:\\Windows\\PrefetchC:\\Windows\\Temp C:\\Users\\Public\\Documents\\Recent C:$Recycle.BinC:\\Windows\\Logs C:\\Windows\\System32\\config C:\\Windows\\SoftwareDistribution USERNAME C:\\UsersDownloadsDesktop0_o AppData\\Roaming\\Notepad++Documents168133: we also see strings pertaining to chacha20, giving us a small idea on what this ransomware might entail\nStatic Analysis # Now we can load the binary into IDA 8.3 Freeware\nAnd we find main fairly easily\nGetting to main # In a rust binary unlike the C/C++ binaries, the main is not actually a main, rather it passes the function pointer of main to another function called lang_start\nAnti Debug Check # Now heading into the actual main we see, An IsDebuggerPresent call\nSo we can easily either NOP out these bytes or convert the jnz to jz as such\nNow this would help us during our debugging session, if we need to step through this function\nLastinputinfo # Next we have this block of code between lines 123 - 130\nGoogling for the struct LASTINPUTINFO\nAs it says, we get a structure filled with the last input info\nThis function fills the dwTime field of the structure with the milliseconds (tick count) of the last input info. The milliseconds here are from the start of system_time\nAnalysing the next block of code, GetTickCount() # We see GetTickCount() being called As mentioned, it returns the number of milliseconds since the system was started, And that is being subtracted from the time the last input was taken and compared against 59999, and is evaluated true if greater. Ie it would be false if it is under 60000ms, 60000ms is 60s i.e 1 min. The malware checks if the computer was idle for the last minute, if it was idle, then it exits . This is one of the conditions For the next block of code above, in the if condition we see it takes a fills a structure plii with the current cursor position and and then sleeps for 5 seconds, then measures the next cursor position and we can see a ‚Äòmm_cmepeq_epi132‚Äô , indicating a compare, thus these two measured cursor positions are compared and if it is the same then it is marked as True, at which point the malware exits and stops running as well.\nOnce the if condition is cleared,\nin the block of code below We see the use of a function ‚ÄúGetAsyncKeyState‚Äù\nGetAsyncKeyState() # We can look up the MSDN webpage associated to GetAsyncKeyState\nAs it mentions, it determines which key was pressed during the latest IO operation\nAnd we have GetAsyncKeyState(1) and GetAsyncKeyState(2)\nWhere args 1 and 2 correspond to : Under the virtual key_code\nWe also see, Based on this we can see it keeps track of how many times left click was registered and how many times right click was registered in the variables v1 and v2\nNow we understand that the malware won‚Äôt run or proceed further until and unless a particular amount of left and right clicks have been registered which in our case in 6 and 5 respectively\nThis clears out the doubt on why the malware wouldn\u0026rsquo;t run under normal circumstances, and it requires a specific set of actions to be done in a certain number for it to proceed executing the malicious payload\nAfter that we notice some basic initialization type code until line 179 (below)\nAnd tracking that particular offset 140002CFF0 leads us to functions which looks like a heapfree and memory allocation, all of this sounds like basic initialization. So not much use for us to actually reverse this part of the code\nsub_140023030() AKA Unkn_Func_1 # has been rechanged to going into the function it seems too much to sit and revers statically, I\u0026rsquo;ll come back to this later and look at it dynamically\nsub_14000C1B0() AKA Get Environment Variable # Next interesting function is\nThis function seems to take an arguemnt as \u0026ldquo;USERNAME \u0026quot; and a hObject to output the value\nGoing inside the function we see it does make use of the USERNAME argument in calling the windows API So we go with the understanding that the hObject that goes out of this is the ENV VARIABLE\nfilepath setting # this block of code seems like it is reading an existing string(unk_14002D040) at particular offsets and it is appending whatever is read from env_struct to parts of this string\nA hunch we can easily form out of this entire code block is that it is using our system USERNAME to get the correct full path of these directorys\nC:\\Users%USER%\\Downloads\\ C:\\Users%USER%\\Desktop\\ sub_140011F80 mentioned here seems to be taking these Going inside it, we see it basically has a memcpy inside it\nso we aptly can rename sub_140011F80 -\u0026gt;concat\nAlso, we see the output in one is being used in the other after being put through another function sub 140018D50, which just returns the string as is, this can be hunched of as unrwap() in rust\nsub_140005700 just calls a freeheap within itself, so we can rename that as freehap as well\nso now the cleaned up statically analysed block of code looks like And going by the order of the string, I would assume that it is being put to use in the same order that it is stored in\nC:\\Users%USER%\\Downloads\\ C:\\Users%USER%\\Desktop\\ So we can rename the above image to kind of fit our mental image of what is happening\nRansom_note_file_name # As we can see, first 17 bytes of this offset is read in Create ransom file # when went into the highlighted function, we see calls such as which leads us to understand that this now creates a file under the name\nAzr43l_README.txt.\nAnd we see this being used to the very last concatednated file_path, which under our assumption is Desktop\nWrite ransom note to desktop # In the above image we see sub_140004550, we see calls to NtWriteFile\nand this function by itself takes arguments to the ransom_note hence it is safe to assume that it does write the ransom_note onto the newly created Azr43l_README.txt\nThen after this block of code it\u0026rsquo;s mostly a bunch of heap_free calls until line 252\nsub_140017EF0() AKA unkn_func_2 # We see the same routine yet again and some file_path\\Azr43l_README.txt being passed as an arg to the above mnetioned func. We don\u0026rsquo;t understand much from looking into this, this is yet another function to be looked at dynamically\nRansom note drop pt.2 # Starting from line 275 we see a similar routine again of it again wrting the same content to this new file, it\u0026rsquo;s just that it is in a different location (which can be found out dynamically)\nsub_140001450 AKA Unkn_Func_3 # Now we get to what seems to be the crux of the ransomware. We see a new function which we have named unkn_func_2 take in the earlier unkn_func_1\u0026rsquo;s output and it also takes the user_download_folder path, going into the function, it only confuses us even more, so for now we stick to just renaming it like so\nContinuing # As I continued to scroll down more, I saw a similar routine of unwrapping a string and unkn_func_3 being called on them at which point I thought, static analysis is gonna get us only so far, and that we can start looking at the file dynamically\nTraiging pt.2 # Before we start with the dynamic analysis of the ransomware, it would be helpful to debug and get to code faster if we patch out these three key areas\nThe anti debug check as mentioned above The cmp for the number of clicks both 5 and 6 Just for fun I decided to run this binary now, in a controlled environtment ofcourse to see what this does, and as expected so far, we see a ransom note in Desktop and we also see certain files gettting encrypted and being renamed as .azr43l files\nfor example\nDynamic Analysis # NOTE:\nAll the debugging that is being shown in this writeup has been purely done inside and isolted VM. And under no condition, should you try to replicate it on the HOST.\nNow we can start with the dynamic analysis of the ransomware\nBecuase we patched out the above mentioned areas of jnb to respect jb and jz to jnz, debugging is a smooth sail\nwe get to the first function we wanted to look at dynamically\nsub_140023030() AKA Unkn_Func_1 AKA random_24_gen # Initially we just kept track of the output value of this function and func_1_output seems to be generated on runtime\nand when tried to run multiple times, we see different values being generated\n1) 2) 3) Looking at this we see, it generates\nRandom value 24 bytes so we can go ahead and change the name of the func to Get_env_Variable # Can confirm that it does take the given struct adn does return the %USER% value in the struct\nSetting Filepath # we can confirm those particular file_paths now and we do see the actual path and we can name the variables accordingly\n1) 2) 3) Ransom_note_path # The ransom note path can also be found as shown below C:\\Users\\Ryuzaki\\Desktop\\Azr43l_README.txt Unkn_func_2 # Now we come to unkn_func_2 We see the first arg being some structure, and the second one being the desktop_ransom_note file path We see plii return 1 at the cb.size so it doesn\u0026rsquo;t even enter the block of code under the if condition below\nUnkn_func_3 # Now we come to this part of the code\nas we can see, from renaming the above variables in the \u0026ldquo;setting filepath\u0026rdquo; we get an idea as to what all args are being passed into this function namely\nfile_directory_path (download folder in this case) file_directory_path_len (confirm from debugging) random_generated_val (24 bytes) Statically looking at unkn_func_3 we see a lot of operations pertaining to an encryption of sorts and we see some variables named randombuffer , we see this string 98238588864125956469313398338937 being xorred with something\nand we also see the use of the string .azr43l, as seen above in the second triaging attempt\nSo going based off of these hunches, now I name the current function that we are in right now, unkn_func_3 as encrypt()\nEncrypt() - the heart of the ransomware # Going into encrypt, we come across the first function which takes the file_path and the file_length as arguments, v53 being the output Currently in our case, the file_path is the download folder and the file_length is accordingly set.\nsub_140016D10 # Going inside the above mentioned function, we see\nI have renamed some variables as differently variants of \u0026ldquo;file_path\u0026rdquo; accordingly again and again ,becuase the pointers were being copied and switched around\nAs we keep scrolling down, most of it seem pretty basic and normal assigning operations with nothing much being operated upon. Until this part,\npath file before that particular function call was just our downloadpath file C:\\Users\\%USER%\\Downloads\\\nBut after that call,\nit is appended with a * like so\nAnd in windows * is reserved and is not allowed to be used as an actual file name.\nIt is mostly used to search under a particular directory, a regex the means anything meatching that particular pattern of string. So rn it seems as if that function was supposed to append a * depending on whether or not the pathfile ended in a \u0026ldquo;\u0026quot; character.\nso we rename that function sub_7FF792300B20 like so\nand continue ahead.\nsub_14001A640 AKA convert_to_widechar # takes our file_path as arg and once it exits, we see this when we track our filepath variable hence it has been aptly named\nsub_1400194E0 AKA get_full_path_name # it takes lpfilename and our file_path as argument, and output\u0026rsquo;s the fullpath name under lpfilename\nWhen we look inside the function we see\nand stepping over this function while debugging also confirms the same. In our case it returns the same C:\\Users\\Ryuzaki\\Downloads\\*\nNow coming to next block of code\nFindFirstFileW # We google this on msdn and we FindFirstFileW\nit returns a handle to the file and an output value under the second arguemnt containing information about the file under the structure of FIND_DATAW\ntypedef struct _WIN32_FIND_DATAA { DWORD dwFileAttributes; FILETIME ftCreationTime; FILETIME ftLastAccessTime; FILETIME ftLastWriteTime; DWORD nFileSizeHigh; DWORD nFileSizeLow; DWORD dwReserved0; DWORD dwReserved1; CHAR cFileName[MAX_PATH]; CHAR cAlternateFileName[14]; DWORD dwFileType; // Obsolete. Do not use. DWORD dwCreatorType; // Obsolete. Do not use WORD wFinderFlags; // Obsolete. Do not use } WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA; The key point to note is this structure contains the filename of the file that it has an info on, so our program is trying to leverage this method of finding every filename inside a given directory\nSO now we can rename the args to more understandable names Next as we keep executing, we see our file_info being copied into the a1 ie our arg1 which we initially thought wld be the output of this particular function as well\nAnd then it returns\nso to summarize,\nbasically this function takes a particular argument, checks if it is a directory, if it is , it would add the \u0026quot; * \u0026quot; operator at the end of the directory and calls FindFirstFileW and gets the file info based on that particular file and returns that in a struct\nSo we name it as as get_file_data\nSuspicious xmmword # Just looking at the assembly side by side\nwe see a bunch of bytes getting copied over into xmm6 and xmm7 , we just keep that in mind and go ahead\nsub_7FF7922FC850 # Not used.\nNext # While debugging we see the memcpy 2\u0026rsquo;s first argument is populated with the filename from get_file_data pointer\nNow in my case it turned out to be another directory that is stored first\nContinuing,\nwe see now the if condition fails at sub_7FF792302070 and goes onto the else condition only to call encrypt function again recrusively Recursive encrypt - iteration 1 # Now are are recrusively inside the encrypt function with the argument as C:\\Users\\Ryuzaki\\Downloads\\DebugView\nwe go through the same steps of finding the first file handle and it\u0026rsquo;s details and names\nFor the purpose of creating this writeup I had made a dummy file under downloads directory and filled it with loerm ipsum content, and now that this file is taken in it passes throuhgh the above function wih no issues, I can form the hunch that the above function sub_7FF792302070 is to check if a particular path is a directory or not\nwe\u0026rsquo;ll go ahead with that\nsub_7FF7922FC6F0() # passing through this function and looking at the value inside RandomBuffer, show\u0026rsquo;s us\ntxt - meaning the function serves it\u0026rsquo;s purpose to find the extension of the loaded file.\nthen this extension is compared against azr43l if the extension is already azr43l then it enters the else condition and looks for more files in the same directory\nand if the extension is not the same then it enters into the if condition\nThis throws more light on the ransomware, that once it encrypts it\u0026rsquo;s files it wld extend it with azr43l\nIn the next check it makes sure it doesn;t encrypt the ransom_note.txt\nif it turns out to be the ransom note then it exits ,looking for the next file in the directory\nnext we see inside this unkn_func_0 we spot it\u0026rsquo;s a CreateFile API\nhence we name this function as create_file\nthen as we go down, we debug more to spot a particular function\nsub_7FF792301E20\nThat seems to return teh filename alone from the huge file path, for example in our case it is - just_a_test_doc\nThen from further debugging we see function calls such as which I have renamed it, because it returns the technical last byte being \u0026ldquo;\\0\u0026rdquo;\nThen it takes the file_name and appends to it the .azr43l extention through these two memcpy\nNext during further debuggin we notice and rename a particular function call that just returns teh current directory path that the file is in\nand that it is getting copied to Random buffer\nNext in the subsequent lines of code\nwe see random buffer being appended to file_directory there_by creating this basically it appends .azr43l to the path of the old filename and it creates a new file_path\nCreating Encrypted File # Now we notice it creates a new handle and opens it to the new encrypted file under the new name of\nC:\\Users\\Ryuzaki\\Downloads\\DebugView\\just_a_test_doc.txt.azr43l\nThen it\u0026rsquo;s just doing a few copies of file pointers which is not really necessary for us atm it provies a malloc space for file_contents then we finally come to reading the file\nOpenfile # Opening the open_file function we see\nhence we name it to be open_file\nnow we can see the file contents as well\nRandom_num_generator # we come across another function which only seems to take two args\nopening it we see,\nSo now we have renamed it as we can see the RandomBuffer is now stored on the stack\nThe actual encryption # We see two function calls here\nsub_7FF7922F8600() and sub_7FF7922F88B0() Coming to the first one\nsub_7FF7922F8600() # sub_7FF7922F8600(\u0026amp;RandomBuffer, \u0026amp;random_buffer, 32LL, random_24_bytes_val, 12LL) The arguments it takes are : Arg 1 and 2 RandomBuffer that we just generated right now\nArg 3 : 32 Arg4: previously generated 24 bytes random value Arg 5 :12\nA major point to note is that this doesn\u0026rsquo;t involve our file_contents at all\nEntering inside this function, this is what it looks like\nwe see strings like chacha20 which certainly do pique an interest here\nWE see another function being called internally\nsub_7FF7922F86C0()\nwhich returns the value in v10\nand now v10 contains expand 32-byte k\ncurious on this we google and a small googling let\u0026rsquo;s us know that this is the initial state of the chacha20 encryption alrogithm\nTherefore now we can rename this funtion as init_chacha20\nAnd googling more about chacha20 in rust gives us this page\nin this we can clearly see that chacha makes use of a 32 byte key(which in our case is random_buffer) and a 12 byte nonce(which in our case is the 24 byte random_val)\nwe keep that in mind that it takes only the top 12 bytes of this 24 byte random_val\nsub_7FF7922F88B0() # Coming to the second function, we now see\nArg1 : expand 32-byte k followed by the random_buffer in memory followed by the first 12 bytes of the 24_byte_val Arg2 : file_contents Arg3 : A number(assuming it\u0026rsquo;s the size of the file) Arg4 : unsure Arg 5: unsure\nThis is arg 1: followed by\nthe 32 byte random value\nfollowed by the 12 byte nonce all of this is on the stack and now this aligns with what we saw in the rust documentation and hence, now we are able to get a clear picture on how and what it is encrypting\nwe basically have the random_val and the nonce that is needed to encrypt and decrypt in chacha20\nEncrypted data # After encryption the location where the 12 byte nonce was stored is where the encrypted data is stored as well, the pointer is being overwritten\nSuspicious xorring # This is pertaining to the earlier suspicious group of bytes that we saw getting pushed into xmm words\nrn the very same byts that are storred in xmm8 and xmm7 are getting xorred with the 32 byte random value that we just generated\nWriting to encrypted file # This xorred value is now being appended to the very end of the file_data that we just encrypted.\nThis helps us recover the randomvalues that were generated for each file\nMeaning, to decrypt now we have got the random_32_byte key we would only require a 12 byte nonce that needs to be used in decrypting\nAnd right now finally as everything goes, we take the encrytped bytes and write it into the new file that we just generated with the .azr43l extension\nDelete old file # Once the new file has been written now, there is no need to keep the original old file around which is now getting deleted from the system\nAnd the rest of this function is just clearing memory spaces and freeing the heap\nAnd thus that brings us to the end of the encrypt function\nOut of Encrypt # After getting out of the encrypt function we continue down into the code\nwe see it assigning new path now, but because it follows the same routine I don\u0026rsquo;t want to bloat the writeup with redundant info\nEncrypting desktop # This block of code encrypts the desktop content\nEncrypting notepad++ # Then it goes onto encrypt C:\\Users\\Ryuzaki\\AppData\\Roaming\\Notepad++\nEncrypting Documents # Encrypts documents twice\nSocketConnection # Now we get to the intersting part again, different from the few previous code blocks\nWe see here what looks like an IP addr\n192.168.1.33\nand right below we seem to have been given the port Now hObject seems to be initialized with ip and port binding them into a single struct for sockets\nas we track hObject we see it is being passed onto which takes the IP , Port and the random_24_byte_val, which we now know to be the nonce\nit sends the nonce to IP 192.168.1.33:6969\nsub_1400024B0() # And last but not least we come to the final function which is yet to be analysed\nGoing into the function we see it has all these strings,\nand we see a bunch of function calls of the same function(sub_1400172B0) but with different strings as different args\nGoing into the function we see a lot of calls\nNtCreateFile GetFileInformationByHandleEx DuplicateHandle GetCurrentProcess\nWe cld have sit and analysed all this, but to save us some time, we cld step over all this functions and go in search for those particular directoris mentioned there such as\nC:\\Windows\\System32\\winevt\\Logs C:\\Windows\\Prefetch C:\\Windows\\Temp C:\\Users\\Public\\Documents\\Recent C:$Recycle.Bin C:\\Windows\\Logs C:\\Windows\\System32\\config C:\\Windows\\SoftwareDistribution And after analysis, it\u0026rsquo;s easy to understand and to formulate a hunch that this particular funtion was meant to remove all the files inside these directories of valuable DFIR artefacts as well for anti-forensic purposes.\nnow as the anlysis is over , we will go ahead and answer the questions\nC2 server IP # 192.168.1.33:6969 ","date":"19 March 2024","externalUrl":null,"permalink":"/posts/bi0sctf_ransomware/","section":"Welcome to Posts!","summary":"\u003cp\u003e\u003cstrong\u003etl;dr\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChallenge 2 of Batman Investigation series\u003c/li\u003e\n\u003cli\u003eRansomware Investigation\u003c/li\u003e\n\u003cli\u003eRust based Ransomware Analysis with process dump analysis to recover the randomly generated decryption vector and windows malware analysis\u003c/li\u003e\n\u003cli\u003eRecovering from a ransomware attack\u003c/li\u003e\n\u003c/ul\u003e","title":"Batman Investigation III - Th3 Sw0rd 0f Azr43l - bi0sCTF 2024","type":"posts"},{"content":"","date":"19 March 2024","externalUrl":null,"permalink":"/tags/bi0sctf/","section":"Tags","summary":"","title":"Bi0sCTF","type":"tags"},{"content":"","date":"19 March 2024","externalUrl":null,"permalink":"/tags/forensics/","section":"Tags","summary":"","title":"Forensics","type":"tags"},{"content":"","date":"19 March 2024","externalUrl":null,"permalink":"/tags/ransomware/","section":"Tags","summary":"","title":"RansomWare","type":"tags"},{"content":"","date":"19 March 2024","externalUrl":null,"permalink":"/tags/reversing/","section":"Tags","summary":"","title":"Reversing","type":"tags"},{"content":"","date":"19 March 2024","externalUrl":null,"permalink":"/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":"","date":"24 March 2023","externalUrl":null,"permalink":"/tags/aes_cbc/","section":"Tags","summary":"","title":"AES_CBC","type":"tags"},{"content":"","date":"24 March 2023","externalUrl":null,"permalink":"/tags/htbca23/","section":"Tags","summary":"","title":"HTBCA23","type":"tags"},{"content":"tl;dr\nDynamically resolved hashed API Tls_call_back based anti-debug check AntiDebugFlag check implemented using ProcessInformationClass AES_CBC decryption of image to find flag Challenge points: No. of solves: Solved by: retr0ds || AmunRha Challenge Description # You finally manage to remotely connect to a computer onboard the alien vessel to shut down the defense mechanisms. However, it instantly starts acting up and ends up deploying malware as a defense mechanism. All your documents including your hard earned map of the vessel topology is now encrypted. And we are given two files\nChallenge.exe vessel_map.jpeg.owo So, on the base level, it ought to be malware that encrypts files Now we move on to figuring out how.\nTriaging: # Just running the binary inside a VM doesn\u0026rsquo;t seem to affect much inside the binary, nor is trying to pass it as an argument seem to make a difference.\nAnd trying pintools on the binary also seems to result in an error. Hmm, that\u0026rsquo;s odd, seems to have implemented an anti-debug check\nStatic Analysis: # It is UPX packed, so we go ahead and unpack it using upx -d challenge.exe\nNow, load it back again in IDA.\nFunctions: # main\nWe find main() fairly easily, given it\u0026rsquo;s not stripped\nsub_140001080 (AKA) GetFuncByHash Main first calls these functions with an integer value return values are in v4 and v5. And later v4 and v5 are called dynamically as functions. So it is safe for us to assume that this would be a GetFunctionByHash\nsub_1590 Unsure of what it does, we\u0026rsquo;ll keep it aside for now\nv4 and v5 functions The dynamically resolved functions are now called where unkn_array_1 is a byte_array of length 16. We hope to find this out later during the process of debugging to see what are the APIs being called\nsub_140001210 (AKA) Unkn_func_3 This function also employs GetFuncByHash() and calls another API, it is safe to assume v5 might be the return value. This in turn is being used as an argument in the next function call based on the function parameter a1 (a1 passed as v8 in main, is the variable used inside the API called by v5 and v4)\nWe\u0026rsquo;ll get to how and why I named the byte array unkn_16_byte in the next sub_function\nsub_140001290 (AKA) Encrypt_Func\nNow we get to the Function which seems to give us a basic idea of what exactly is being carried out in terms of encryption inside the binary.\nWe seem to check for this directory,\nand a bunch of operations(analyzed below) later we see below a set routine of syscalls OpenFile ReadFile CloseFileHandle\nSome function with two bytearray\u0026rsquo;s as args and v17, v18(the buffers from readfile)\nThen Writefile with v18,v17 as args CloseFileHandle\nSo it is safe to assume and form a HUNCH that,\nIt takes in Two buffers B1 (unkn_16_byte) and B2 (unkn_array_1) each 16 bytes in length Reads from File A Encrypts file_bytes using B1, and B2 under some Encryption Algorithm and stores it into a new file. Both of these B1 and B2 are 16 bytes long and they Also going by the strcpy(), a hunch can be that it stores the filename and is appended the \u0026ldquo;.owo\u0026rdquo; before writing to it. The current hunch is going to be that the encryption algorithm used is AES under CBC mode given it has a key as well as a\nDynamic Analysis # Current Objective:\nGet the debugging process up and running Attaching a debugger and stepping through results in an exception being thrown with error code 0x5 for MEMORY_ACCESS_VIOLATION inside ntdll. Now, that\u0026rsquo;s interesting!! So, the malware author implemented either an existing or a custom anti-debug check method/routine wherein the process can identify if it is being debugged before even it gets to the challenge file\u0026rsquo;s code/the start()\nSo, the program is started by the OS, and during the RT setup, some function checks if there is a presence of a debugger or not.\nNow we go back into the binary and search for \u0026ldquo;Debugger\u0026rdquo; inside functions we get nothing, next thought is to check for it in strings, and Lo and Behold! we are led to Tls_Callback_0\nSo googling about this we get to : Tls_Callback_0_Anti-Debug\nTLS callback is a function that is called before the process entry point executes.\rIf you run the executable with a debugger, the TLS callback will be executed before\rthe debugger breaks. You can see the TLS callback is called by the loader during\rprocess startup. So right now we just patch the assembly from a jz to jnz to let debuggers work through this\nAnd BOOM! now we can enter the user code of the binary.\nObjective : Get the debugging process up and running\nCurrent Objective: Figure out what APIs are being resolved by hashing\nIn main :\nv4() \u0026lt;\u0026mdash;\u0026ndash;\u0026gt; NtAllocateVirtualMemory v5() \u0026lt;\u0026mdash;\u0026ndash;\u0026gt; NtWriteVirtualMemory\nSo it creates a virtual memory space and writes the contents in unkn_array_1 into that memory space\nWe set a Hardware Breakpoint at this place just in case In sub_1210 (AKA) Unkn_func_3 :\nv3() \u0026lt;\u0026mdash;-\u0026gt; NtQueryInformationProcess\nObjective down: Figure out what APIs are being resolved by hashing\nFunction specific reversing: # sub_1590 # Upon debugging we see this function achieves nothing nor does return anything useful under any register, it copies the buffer, runs a while loop for 0x1600 times, set the variable result to that value and returns result.\nsub_140001210 (AKA) Unkn_func_3 # Stepping into this, we found out the API being called is NTQueryInformationProcess, and it returns v5.\nSo we pull up NtQueryInformationProcess\u0026rsquo;s MSDN\nI have a suspicion that this might involve some form of tomfoolery with the PEB structure or ProcessInformationClass given a constant value has been passed on as the second argument\nThe next step was to google and confirm our hunch,\nSearch as such, gives us what we need right in the first link Anti-Debug-Checks\nSo the third argument (ie) v5 is dwProcessDebugFlags, and, if the process is being debugged it would be set to 0, and if not 1\nWith that in mind, we now move on to the next function call inside the binary,\nNow this function is being called by using the first argument as the function pointer, and a1 happens to be the unkn_16_byte (which I assume is either the key or IV), and the second argument is the dwProcessDebugFlag\ndwProcessDebugFlag is 0 if being debugged\ris 1 if not being debugged Now, we know the calling convention of windows functions\nSo we manually change the EDX register value to 1 and continue execution by hitting f7\nnow converting it all to code,\nwe see it makes use of xmmwords (128-bit registers) to do some operations\nWe are unsure of such opcodes, but our goal rn is to retrieve the unkn_16_byte array as if the program was never debugged.\nAnd we seem to easily accomplish that by just passing through the instructions and finally examining the RCX value before the return.\nWe get the unkn_16_byte array to be 6D597133733676397924422645294840\nsub_1290 (AKA) EncryptFunc # This function seems to get the HANDLE to the first file under \u0026ldquo;C:\\Users\\Administrator\\Documents\\\u0026rdquo;\nThen it goes onto this part of the code The above snippet is responsible for just copying over the file path string from the buffer to the variables. Unimportant.\nThis above part of the code is responsible for converting the filename to UTF-8 from UTF-16(Microsoft/Windows stores text in the form of UTF-16 to ensure broader encompassing of symbols/characters, this is AKA wide char where each character is given a set space of 2 bytes,in the event only a single byte is used, the unused byte is nulled out)\nThen the UTF-8 converted text is put in the routine of\nOPEN\rREAD\rCLOSE\r\u0026lt;ENCRYPT\u0026gt;\rOPEN\rWRITE\rCLOSE The Core # And now we get to the core of the binary This encrypt function determines the entire functionality purpose of the binary\nBefore going into the function, we see it takes in the unkn_16_byte we retrieved and another array with just the null bytes(chances for it being the IV incase this is AES)\nNow we step into the function, by hitting f7 we get bytes, we continue hitting c to convert it to code and p to define it as a function in IDA\nOnce we are a couple of functions in, we notice\nChecking out the byte array,\nWe see it is exactly the S-box used in AES.\nNow we have confirmed the encryption algorithm being used as well by taking a step-by-step approach.\nAll we have left is to decrypt the given .owo file and that should give us the FLAG\nThe Script # from Crypto.Cipher import AES f1 = open(\u0026#34;flag.png\u0026#34;,\u0026#34;wb\u0026#34;) x = AES.new((key=b\u0026#39;mYq3s6v9y$B\u0026amp;E)H@\u0026#39;, mode=AES.MODE_CBC, iv=b\u0026#39;\\x00\u0026#39;*16) f2 = open(\u0026#34;vessel_map.jpeg.owo\u0026#34;, \u0026#34;rb\u0026#34;) bytes = f2.read() f1.write(x.decrypt(bytes)) key = b'mYq3s6v9y$B\u0026amp;E)H@' is our unkn_16_byte in bytes format iv = 16 null bytes (ie) \u0026lsquo;\\x00\u0026rsquo; * 16\nOR\nWe can use CyberChef To retrieve the flag file\nThe Flag # HTB{573pp1ng_1n70_und0cum3n73d_4113n_4p15}\n","date":"24 March 2023","externalUrl":null,"permalink":"/posts/vessel_cartographer_htb2023/","section":"Welcome to Posts!","summary":"\u003cp\u003e\u003cstrong\u003etl;dr\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDynamically resolved hashed API\u003c/li\u003e\n\u003cli\u003eTls_call_back based anti-debug check\u003c/li\u003e\n\u003cli\u003eAntiDebugFlag check implemented using ProcessInformationClass\u003c/li\u003e\n\u003cli\u003eAES_CBC decryption of image  to find flag\u003c/li\u003e\n\u003c/ul\u003e","title":"Vessel Cartographer HTBCTF23","type":"posts"},{"content":"","date":"19 February 2022","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":" Week 1(13th Feb 2022-18th Feb 2022) # Started with android reversing, went through few writeups and videos. Attempted to solve hayyim ctf 2022 breakable.apk, failed to fathom the code, so started off with solving droids-series from pico ctf\nNew Tools learned # d2j-dex2jar-to convert the apk to its java archive d2j-dex2jar filename.apk -o filename.jar\napktool-to extract the resources and the smali code apktool d filename.apk -o foldername\njd-gui-to view the graphical disassembly of the jar file jd-gui filename.jar\nAlso used android studio to emulate the apk\nChallenges solved # picoCTF # droids0-involved looking at the event log in android studio and ctrl+f for \u0026ldquo;pico\u0026rdquo; droids1-involved finding the if condition ,taking the resource number used in .get() to find the pasword, we see is stored in \u0026ldquo;password\u0026rdquo; string, looking under \u0026ldquo;password\u0026rdquo; in strings.xml \u0026hellip;\u0026ldquo;opossum\u0026rdquo; gets us the flag droids2-involved assembling pieces of a string stored as an array in a particular order(\u0026ldquo;dismass.ogg.weatherwax.aching.nitt.garlick\u0026rdquo;) to get flag Week 2(20th Feb 2022-25th Feb 2022) # Continued with last week\u0026rsquo;s learning and started with understanding hwo to patch a apk.For this I looked into droids3 and droids4 from pico ctf.\nNew Tools learned # keytool - Generate a new key to sign the build keytool -genkeypair -v -keystore key.keystore -alias publishingdoc -keyalg RSA -keysize 2048 -validity 10000 jarsigner - to sign the apk after patching it jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore ./key.keystore \u0026lt;path to apk\u0026gt;.apk publishingdoc Challenges solved # picoCTF # droids3-involved patching the smali code from moving to \u0026ldquo;nope\u0026rdquo; function to \u0026ldquo;yep\u0026rdquo; function for any input given droids4- ","date":"19 February 2022","externalUrl":null,"permalink":"/posts/android_reversing_basic/","section":"Welcome to Posts!","summary":"This covers basic android reversing that I did in my freshman year","title":"Android Reversing - Basic Setup","type":"posts"},{"content":"","date":"19 February 2022","externalUrl":null,"permalink":"/tags/picoctf/","section":"Tags","summary":"","title":"PicoCTF","type":"tags"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/about/","section":"Welcome to About!","summary":"Learn more about me and why I am starting this blog.","title":"Welcome to About!","type":"about"}]