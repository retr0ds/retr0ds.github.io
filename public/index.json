
[{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/blog/","section":"Tags","summary":"","title":"Blog","type":"tags"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/pop_a_calc/","section":"Tags","summary":"","title":"Pop_a_calc","type":"tags"},{"content":" Writing the Shellcode x86 W32 # 32 bit also goes through the same steps as 64 bits so I woudn\u0026rsquo;t be explaining it in detail rather, I have commented it on the side for you to understand and pick up based on context from x64\nxor eax, eax\rxor ebx, ebx\rmov ebx, [fs:ebx + 0x030] ; PEB loaded in eax\rmov ebx, [ebx + 0x0c] ; Address of PEB_LDR_Module is loaded (in 32 bit it is at offset 0c)\rmov ebx, [ebx + 0x14] ; Address of InMemoryOrderModuleList is loaded this is pointing to kernelbase.dll\rmov ebx, [ebx] ; Pointing to ntdll\u0026#39;s ldr_data_table_entry\rmov ebx, [ebx] ; Pointing to kernel32.dll\u0026#39;s ldr_data_table_entry\rmov ebx, [ebx + 0x10] ; Base Address of kernel32.dll is now loaded\r;--------------Base address of kernel32dll is now loaded into ebx------------------\rpush ebp ; Storing prev stack base\rmov ebp, esp ; Setting up the base of new stack\rsub esp, 18h ; Setting up the new stack frame (to accomodate for the lack of registers in x64)\rxor esi, esi ; Clearing out esi manually\rpush esi ; To fix the alignment on the stack\rpush 00636578h ; \u0026#34;\\00cex\u0026#34; is being pushed onto the stack\rpush 456e6957h ; \u0026#34;EniW\u0026#34; is being pushed onto the stack\rmov [ebp-4], esp ; WinExec\\x00\rmov eax, [ebx + 3Ch] ; RVA of PE signature\radd eax, ebx ; Address of PE signature = base address + RVA of PE Signature\rmov eax, [eax + 78h] ; RVA of Export Table Directory\radd eax, ebx ; Address of Export Table Directory = base address + RVA of Export Table Directory\rmov [ebp-08h], eax ; Address of Export Table direcorty is being moved into ebp-0x8 for future purposes mov ecx, [eax + 24h] ; RVA of Ordinal Table\radd ecx, ebx ; Address of Ordinal Table = base address + RVA of Ordinal Table\rmov [ebp-0Ch], ecx ; Address of Ordinal Table is being moved into ebp-0xC\rmov edi, [eax + 20h] ; RVA of Name Pointer Table\radd edi, ebx ; Address of Name Pointer Table\rmov [ebp-10h], edi ; Address of Name Pointer Table is being moved into ebp-0x10\rmov edx, [eax + 1Ch] ; RVA of Export Address Table\radd edx, ebx ; Address of Export Address Table\rmov [ebp-14h], edx ; Address of Export Address Table is being moved into ebp-0x14\rmov edx, [eax + 14h] ; Number of exported functions is taken at the offset of 0x14 from eax, eax holds the Address of the Export Table Directory\rxor ecx, ecx ; ecx is cleared\rmov ecx, 0x7 ; ecx is loaded with the length of \u0026#34;WinExec\u0026#34;\rdynamic_api_resolve:\rmov edx, esp ; The last thing we pushed onto the stack was WinExec since which esp has not been changed, so it\u0026#39;s address is loaded into edx\rpush ecx\rxor eax, eax ; eax is cleared to be used as counter\rloop:\rmov ecx, [esp] ; Value at esp \u0026#34;WinExec\u0026#34; is loaded into ecx\rxor edi, edi ; edi is cleared\rmov edi, [ebp - 10h] ; Name pointer Table\u0026#39;s address is being moved into edi\rmov edi, [edi + eax * 4] ; Each entry inside the name pointer table (RVA of the symbol names) are being loaded one by one into edi\radd edi,ebx ; Actual Address of the symbol name = RVA of symbol name + base address\rmov esi,edx ; edx containing the address to string \u0026#34;WinExec\u0026#34; is moved into esi\rrepe cmpsb ; Used to compare strings stored in esi with strings stored in edi byte by byte je get_addr ; If it is equal we get the actual address of the function\rinc eax ; If not we increment the counte\rjmp loop ; Go back to loop in search for the next symbol name\rget_addr: xor ecx, ecx ; ecx is cleared\rmov ecx,[ebp-0Ch] ; Address of Ordinal Table is being loaded from ebp-0xC\rmov ax,[ecx + eax * 2] ; Same counter eax is taken and multiplied by 2 to account for words(as that is how ordinal table is maintained) and it\u0026#39;s added with address of Ordinal Table. This Ordinal Value is stored in ax\rxor ecx, ecx ; ecx is cleared\rmov ecx, [ebp - 14h] ; Address of Export Address Table is loaded into ecx\rmov eax, [ecx + eax * 4] ; And that is now being added with 4 * Ordinal value of the function to get the RVA address of the WinExec function into eax\radd eax, ebx ; Address of the WinExec API = RVA of WinExec + base address xor esi, esi ; esi is cleared\rpush esi ; being pushed onto stack for stakc alignment xor ecx, ecx ; clear ecx register\rpush ecx ; string terminator 0x00 for \u0026#34;calc.exe\u0026#34; string\rpush 0x6578652e ; exe. : 6578652e\rpush 0x636c6163 ; clac : 636c6163\rmov ebx, esp ; save pointer to \u0026#34;calc.exe\u0026#34; string in eax\rinc ecx ; SW_SHOWNORMAL = 0x00000001 is being set\rpush ecx ; tha is being pushed as the second argument\rpush ebx ; Calc.exe is being pushed as the first argument\rcall eax ; WinExec(\u0026#39;calc.exe\u0026#39;, 0x1) is called. Compiling 32 bit # Source # x86 Assembly to pop a calculator\nAssemble # To compile the shellcode and get the object file we can use any assembler, I prefer nasm:\nnasm -f win32 pop_calc_32.asm -o pop_calc_32.o Get Payload bytes # This is not necessary to just compile and run the shellcode. But, assuming we want to use this as payload, this is the one-liner used to generate the instruction bytes\nfor i in $(objdump -D pop_calc_32.o | grep \u0026#34;^ \u0026#34; | cut -f2); do echo -n \u0026#34;\\x$i\u0026#34; ; done Link # Before running this shellcode as such we would requrire linking, which can be done by\nld -m i386pe pop_calc_32.o -o pop_calc_32.exe To Run # pop_calc_32.exe Exit() # That brings us to the end of this blog post. To know more about where to look into how to load shellcode feel free to check out the loading payloads blog.\n","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/series1_pop_a_calc_part_3/","section":"Welcome to Posts!","summary":"Writing the Shellcode x86 W32 # 32 bit also goes through the same steps as 64 bits so I woudn\u0026rsquo;t be explaining it in detail rather, I have commented it on the side for you to understand and pick up based on context from x64","title":"Popping a calculator - 32 bit - Part 3/3","type":"posts"},{"content":" Writing the Shellcode x64 # This part of the blog covers the 64 bit shellcode to pop a calculator. Here I would be explaining my approach at writing source, you can skip right down to the bottom if you just want the compilation information here\nFor the source code you can visit the github repo\nGet The Kernel Base Address # This is the assembly that I ended up writing to get the kernel32 base\nxor rax, rax\rxor rcx, rcx\rmov rcx, gs:[rax + 0x60] ; Address of PEB is loaded\rmov rcx, [rcx+0x18] ; Address of PEB_LDR_Module is loaded\rmov rcx, [rcx+0x20] ; Address of InMemoryOrderModuleList is loaded this is pointing to kernelbase.dll\rmov rcx, [rcx+ 0x00] ; Pointing to ntdll\u0026#39;s ldr_data_table_entry\rmov rcx, [rcx + 0x00] ; kernel32.dll\u0026#39;s ldr_data_table_entry is now referenced\rmov rcx, [rcx+0x20] ; base Address of kernel32.dll is now loaded\rmov r10, rcx ; r10 and rcx have kernel32 base Now looking at this it might not be that comprehensible, so I\u0026rsquo;ll try my best to explain it in the simplest terms\nLine 1 \u0026amp; 2 - Are pretty obvious we are zero\u0026rsquo;ing out the rax and rcx registers\nLine 3 - We load the PEB base address using the offset from the gs register into rcx\nFor the people that are familiar with basic windows internals you might be familiar with the gs register. For the ones new to WinRev\nWhat is gs and fs?\nIn earlier days of computing, there was a need for segment registers like some of which you might have heard of like cs(code segment) es(extra segment),ss(stack segment) ,ds(data segment) etc.\nThese registers were born out of necessity to keep track of these segments and hold their addresses back when memory paging wasn\u0026rsquo;t introduced to manage memory.\nSo they used to keep these registers as base for segments and continue referencing memory at particular offsets from these registers to refer to various resources and code in appropriate sections.\nBut when memory paging came by the need for these registers were obsolete, and yet they are still present in Intel Architecture purely for backwards compatibility reasons and are still supported in different forms.\nWindows specifically uses a few segment registers like fs and gs to keep track of certain important structures related to a process like the PEB and TEB.\nYou can read up more on PEB and TEB on the internet But in simple words let\u0026rsquo;s look at some\nSome important Windows Data Structures (TIB/PEB/TEB) # TIB - Thread Information Block - was used for the non WindowsNT versions, to hold basic process information. Widnows still supports it for backwards compatibilty reasons.\nPEB - Process Environment Block - The Process Environment Block structure contains the process wide data structures which include global context, startup parameters, data structures for the program image loader, the program image base address, and synchronization objects\nTEB - Thread Environment Block - Is an extentsion of the TIB and hence TEB and TIB are used synonymously. The TEB is the structure for Windows NT, 2000, XP, Vista, 7, 8, 10 and 11.\nIn 32 bit, the fs register is used and this is used to point to the TIB of a given thread These are the structure offsets inside TIB at which we can find various other important structural fields\nFS:[0x00] : Current SEH Frame FS:[0x18] : TEB (Thread Environment Block) FS:[0x20] : PID FS:[0x24] : TID FS:[0x30] : PEB (Process Environment Block) FS:[0x34] : Last Error Value\nIn 64 bit, the gs regsiter is used in place of fs to keep track of the TIB structure\nGS:[0x30] : TEB GS:[0x40] : PID GS:[0x48] : TID GS:[0x60] : PEB\nNow using these registers and offset we can find our way into the PEB of any given windows binary.\nLine 4 - Now rcx which holds the base to PEB is added with 0x18 to get to the offset of PEB_LDR_DATA\nAbout PEB and PEB_LDR_DATA structure\nPEB Structure\nAs mentioned easlier, the PEB structure contains various information about a particular process like the base address, if it is being debugged or not, any inherited flags from other parent processes etc.\nSource\nBut the one we are most interested in is the PEB_LDR_DATA.\nThe PEB_LDR_DATA structure is the defining record of which user-mode modules are loaded in a process. Each process has one PEB_LDR_DATA structure associated with it. Its address is kept in the Ldr member of the process’s PEB. PEB_LDR_STRUCTURE\ntypedef struct _PEB_LDR_DATA\r{\rULONG Length;\rUCHAR Initialized;\rPVOID SsHandle;\rLIST_ENTRY InLoadOrderModuleList;\rLIST_ENTRY InMemoryOrderModuleList;\rLIST_ENTRY InInitializationOrderModuleList;\rPVOID EntryInProgress;\r} PEB_LDR_DATA, *PPEB_LDR_DATA; As you can see it contains pointers to three important linked lists\nNamely,\nInLoadOrderModuleList InMemoryOrderModuleList InInitializationOrderModuleList They hold information about the modules (dlls) that are loaded by a proces\nThese are linked lists which share the same elements but they are just linked in a different order as suggested by their names\nTo explain them in brief I shall site it from a book -\nSource - The art of memory forensics book\nInLoadOrderModuleList - This linked list organizes modules in the order in which they are loaded into a process. Because the process executable is alwyas first to load in the process address space, its entry is first in this list.\nInMemoryOrderModuleList - This linked list organizes modules in the order in which they appear in the process\u0026rsquo;s virtual memory layout. The last DLL to load may end up first in memory due to ASLR and other factors\nInIntializationOrderModuleList - This linked list organizes the modules in the order in which their DLL Main was executed. Just because a dll in loaded doesn\u0026rsquo;t mean the DllMain is always called. For example, when we load a dll as a data file or as a resource.\nLine 5 - Now The address to the First Link of the linked list of InMemoryOrderModuleList is loaded.\nThe offset is at 0x20 for 64 bit\nThe first link is pointing to an entry about Kernelbase.dll, so at the offset 0x20 we have LDR_TABLE_ENTRY structure Why InMemoryOrderModuleList?\nWell, In all windows versions, the second and third DLLs in the linked list of InMemoryOrderModuleList is always ntdll.dll and kernel32.dll.\nWe can also accomplish this using InLoadOrderModuleList however, the order of DLLs were changed from Vista onwards, so this doesn\u0026rsquo;t ensure portability of shellcode.\nHence we stick with InMemoryOrderModuleList\nNow after executing line 5 rcx points to the LDR_DATA_TABLE_ENTRY of kernelbase.dll\nLine 6 - Now we load the address of the second entry into the rcx , which now holds the base to ntdll (as the first entry was already kernelbase.dll and it was pointed to by)\nLDR_TABLE_DATA_STRUCTURE\nThe way it works is as depicted below\nSource\nBecause we started accessing from the InMemoryOrderModuleList it keeps pointing to the next InMemoryOrderModuleList entry in the LDR_DATA_TABLE_ENTRY structure. Hence we are able to retrieve ntdll\u0026rsquo;s LDR_DATA_TABLE_ENTRY structure by just calling offset 0\nLINE 7 - Similar to line 6 we now load the next dll (ie) the third dll in memory order.\nLINE 8 - Now we load the base of kernel32.dll at offset 0x20\nNow you may wonder, why is it at 0x20 and not 0x30 as shown in the LDR_DATA_TABLE_ENTRY structure above\nThat because of the very reason mentioned earlier, even though we got to the kernel32.dll\u0026rsquo;s LDR_DATA_TABLE_ENTRY by calling offset-0x00 , we used a pointer to the LIST_ENTRY InMemoryOrderLinks and not to the start of the structure.\nNow to acess the DLL Base we need to find the relative offset from The InMemoryOrderLinks entry. Which ends up being 0x30 - 0x10 = 0x20\nSo now rcx and r10 holds the base address of the kernel32.dll\nLine 9 - It just copies the value inside rcx into r10 for future uses\nGet the address to the Export table # mov ecx, [rcx + 0x3c] ; Find RVA to PE header\radd rcx, r10 ; Points to the PE header\r;mov rcx, [rcx + 0x78] ; RVA of Export table directory\rmov ecx, [rcx + 0x88] ; RVA of Export table directory\radd rcx, r10 ; Export table directory address loaded\rxor r9, r9\rmov r9d, [rcx + 0x1c] ; RVA Export Address Table\radd r9, r10 ; Address to export Address Table\rxor r11, r11\rmov r11d, [rcx + 0x20] ; RVA Export Name pointer table address add r11, r10 ; Adrdess of Export Name pointer table xor r12, r12 mov r12d, [rcx + 0x24] ; RVA of Ordinal Table\radd r12, r10 ; Address of Ordinal Table Here Initially rcx and r10 hold the base of the kernel32 dll\nLine 1 - Here we find the RVA (Relative virtual address from the base of Kernel32), to the the PE Header The offset of 0x3c is never changed and remains the same in the PE format, as it is used to get to the PE header.\nEnough being side tracked, but as you can see in the image, the letter PE show up at the RVA 0xE8 and the offset/the RVA of this can always be found at 0x3C from the base.\nLine 2 - Now we just add this offset (in our case E8) to the base of kernel32 dll to get the pointer to the PE header\nLine 3 \u0026amp; 4 - You may notice that line 3 is commented out and it has been given the same comment as RVA of Export Table Directory as similar to line 4. Now I don\u0026rsquo;t know the reason why, but in our case when I used tools such as PE VIEW and CFF Explorer both the tools showed the offset to find the RVA(Relative virtual address from the base of the dll) for Export Table Directory as 0x88 from the PE header.\nBut, in the countless blogs that I did refer to and did take notes from as I was researching on shellcode and how it works, and many other windows related blogs all of them mention the RVA to be found at the offset 0x78 and not at 0x88.\nSo if someone kind enough to know the reason behind this is out there, feel free contact me and help me understand this 😭😭 and I\u0026rsquo;ll edit this blog and put out the explanation as well.\nBut yes, that being said, the RVA for kernel32.dll\u0026rsquo;s in this particular case is at the offset 0x88 from the PE header, so rn we load that and move it into ecx and add it with r10 the kernel32.dll\u0026rsquo;s base address.\nLine 5 - Next we need to find the Export Table Address. Now you may wonder why is there a need for Export Table Directory and Export Table as two separate things. Why couldn\u0026rsquo;t we just have the Export Table as a single entity so that we could just take the address refering to the name directly.\nWell, the way windows has organized is not just a simple Export Table rather, it\u0026rsquo;s a well defined structure that has general information with regards to exports furthermore it has three important table pointers pertaining to the sole purpose of keeping track of what all functions and modules are being exported out of a binary.\nsource: Export Address Table (EAT)\nExport Address Table pointer It contains the RVA to the list of exported functions. And an associated ord value. The ord value can be used to find the RVA of the exported function Name Pointer Table It contains the names of the exported functions and associated address of this name string in memory. This table can be parsed to find the address to a particular function\u0026rsquo;s address Ordinal Table It contains the address of the various symbols and an associated ordinal value So, these 3 tables are interconnected and are needed for a succesful retreival of an exported function\u0026rsquo;s address.\nLine 6, 7 and 8 - Now we get the register r9 that is going to hold the address of the Export Address Table ready. And the RVA(Relative Virtual Address from the base of the kernel32.dll) to the export address table at an offset of 0x1c from the address of Export table directory.This RVA is always a dword hence we stored it under r9d. And finally we add this RVA to the base of kernel32.dll to get the address to Export Address Table.\nLine 9, 10 and 11 - Now we get the register r11 that is going to hold the address of the ready. And the RVA(Relative Virtual Address from the base of the kernel32.dll) to the Name Pointer Table at an offset of 0x20 from the address of Export table directory. This RVA is always a dword hence we stored it under r11d.And finally we add this RVA to the base of kernel32.dll to get the address to Name pointer table.\nLine 12, 13 and 14 - Now we get the register r12 that is going to hold the address of the ready. And the RVA(Relative Virtual Address from the base of the kernel32.dll) to the Ordinal Table at an offset of 0x24 from the address of Export table directory. This RVA is always a dword hence we stored it under r12d.And finally we add this RVA to the base of kernel32.dll to get the address to Ordinal Table.\nSummary of registers so far:\nr10 - Holds kernel32.dll\u0026rsquo;s base r9 - Holds the Export Address Table pointer r11 - Holds Name Pointer Table Address r12 - Holds Ordinal Table Address\nFind the Base address of the WinExec function # xor rcx, rcx ; rcx is cleared\rmov rcx, 0x7 ; Length of WinExec is loaded into rcx\rmov rax, 0x00636578456e6957 ; \u0026#34;\\00cexEniW\u0026#34; is loaded into rax\rpush rax ; The string name is pushed onto the stack\rpush rcx ; Length is pushed onto the stack\rcall dynamic_api_resolve ; dynamic_api_resolve label is called\rmov r14, rax ; return address of the WinExec is put into r14\rjmp next ; we jump to the next label\rdynamic_api_resolve:\rpop rbx ; return address is stored in rbx\rpop rcx ; Length of the api is stored into rcx\rxor rax, rax ; rax is cleared\rmov rdx, rsp ; Move the address of name of the api into rdx\rpush rcx ; Length of the api is pushed onto the stack\rloop:\rmov rcx, [rsp] ; The counter is being refreshed each time\rxor rdi, rdi ; clear rdi for getting the name\rmov edi, [r11 + rax * 4] ; RVA of function name symbol = Address of Name Pointer Table + counter * 4\radd rdi, r10 ; Address of Function name symbol = RVA of function name symbol + base address mov rsi, rdx ; moving string to be compared into rsi\rrepe cmpsb ; comparing strings in rdi and rsi\rje get_addr ; If equal we jump to get the address\rinc rax ; Else increment counter\rjmp loop ; jump back into loop\rget_addr:\rpop rcx ; Remove string length from top of stack\rmov ax, [r12 + rax * 2] ; Ordinal number of kernel 32 API (WinExec) = Adress of ordinal table + Counter * 2\rmov eax, [r9 + rax * 4] ; RVA of API = Address of Export Address Table + Ordinal number of WinExec * 4\radd rax, r10 ; Address of the API = RVA of API + base address\rpush rbx ; Pushing the Return Address back onto the stack\rret Line 1 \u0026amp; 2 - We start off with clearing out rcx register and set it to be 0x7 which is len(\u0026quot;WinExec\u0026quot;)\nLine 3 - It\u0026rsquo;s \u0026quot;WinExec\\00\u0026quot; in little endian moved into rax\nLine 5, 6 \u0026amp; 7 - Now we push the \u0026quot;WinExec\\00\u0026quot; first followed by the length and call our dynamic_api_resolve label\nContinuing with the control flow,\nLine 11 - We initially store the return address at the top of the stack and store it in rbx.\nLine 12 - 15 - Next value on top of the stack is the length that we pushed. That is being stored back in rcx, then rax is cleared. Now that the length is popped, the value at rsp (ie the top of the stack) is now the string of 'WinExec'. The address of rsp is put into rdx, and rcx is pushed back onto the stack.\nLine 17: Defines the start of a label which is used to loop\nLine 19 - 23 : We move the counter into rcx. Clear rdi for future purposes.Now remember, r11 holds the Address of the Name Pointer Table.\nSo, we add Address of Name pointer table + a counter (this we are mainting to keep track of which index of the Name pointer table is the symbol of our WinExec function at)\nAnd this counter is multiplied by 4 because all the RVA values inside this function is stored in dword format.\nSo, right now we load the RVA of the string into edi, and adding the kernel32 base to get the address of the actual string. We keep this arbitrary string in rdi.\nrdx had our \u0026quot;WinExec\u0026quot; whose address is now being moved into rsi\nLine 25 - 28 - repe cmpsb is executed. Now this is a instruction which compares the string values inside rdi and rsi and sets the zero flag accordingly. It compares it byte by byte, but it\u0026rsquo;s all masked under the single instruction of repe cmpsb.\nNow if the strings are equal then we go ahead and jump to get_addr. Which we\u0026rsquo;ll get to in a bit. But if it is not equal then we increment the counter value by 1, to go to the next RVA of the next string. And we jump back to loop ie (line 17)\nLine 31 - 33 - label get_addr is defined. Now as we know, the top of the stack contains the length of the string \u0026quot;WinExec\u0026quot;. We pop this from the top of the stack back into rcx.\nNow we need to find the ordinal number of the particular WinExec. And ordinal number is simply put an index that windows maintains for each and every export.\nThink of it as a process ID but for exported functions. Each exported function has a unique ID which windows uses to reference the respective functions. And this ordinal number is stored as a WORD. Like so,\nThe names might look too confusing, but as of now just focus on Name RVA and it\u0026rsquo;s type as shown below in the image, Name Ordinal and it\u0026rsquo;s type and Function RVA and it\u0026rsquo;s type in the image\nSo the ordinal numbers are arranged in order as you can see, and a corresponding ordinal number can be found out using the corresponding counter variable.\nBecause we kept track of rax, the index of the RVA of the function, now we can find the ordinal numebr using the same rax counter.\nAll we have to do is just take this counter/index and multiply it by 2 because of WORD and then add it to the base address of the orindal table.\nNow derefencing this calculated pointer would get us the ordinal number of the appropriate name string. Because ordinal numbers are stored as words, we stored it back in ax\nLine 35 - 38 - Now we take this ordinal number and multiply it by 4 (Function RVA is stored as DWORD) and add this to the base of the Export Address Table to get the function RVA of our desired function which is \u0026quot;WinExec\u0026quot;\nWe now take this RVA and add it with r10(the kernel32.dll\u0026rsquo;s) base address to finally get the address of the desired API and store it under the rax register. (The return value of any call function is stored under rax). Now we push the rbx(the register that held on to the return address) and execute ret.\nExecuting ret would take us back to\nLine 7 \u0026amp; 8 - Now address of the WinExec function inside rax is moved into the r14 register and we now jump to a label called next\nLoad the arguments into the WinExec function # ;------------------------now r14 has our API -----------------------------------\rnext:\rxor rcx, rcx ; clears out rcx mul rcx ; rax, rdx and rcx are 0\rpush rax ; Null Terminate string on stack\rmov rax, 0x6578652e636c6163 ; Moving \u0026#34;exe.clac\u0026#34; into rax\rpush rax\rmov rcx, rsp ; into first argument\rinc rdx ; Argument to winEXe show_Normal For this part we shall refer to the msdn documention on WinExec\nAnd as we,\nWe need to give\nthe cmdline string of the program that we want to run The cmdshow argument (this is basically controls how to open the program in what typ eof window) We shall still with just the most basic show_window_normal which holds the value 1 as it can be seen here. Line 1 - 3 - We now reach the next label. rcx is cleared and we use mul rcx to also clear rax, rdx as well\nLine 5 - 7 - Now that rax is 0, we just push it onto the stack to act as a null terminator for the upcoming string that we are about to push.\nThen we mov 0x6578652e636c6163 which is calc.exe in little endian. Now we push it onto the stack as well\nThen we load the first argument into rcx, which is at the top of the stack. The windows calling convention goes like rcx, rdx, r8, r9 .\nNow we increment that value of rdx by 1, setting 1 as the second argument.\nCall the function # sub rsp, 0x20\rcall r14 Here we do sub rsp, 0x20. Because I learnt WinExec clobbers the first 32 bytes on the stack as it is a function that is only to be in use for 16 bit mode and any system running in either 32 or 64 bit mode should use CreateProcess as mentioned in the above image. So this extra space that we create acts as a safety net to prevent it from clobbering our useful bytes.\nNow we go ahead and call r14 which holds the address of WinExec.\nThat brings us to the end of our x64 shellcode.\nCompiling 64 bit # Source Code # The full source and the associated files for this can be found here on my github - x64 Assembly to pop a calculator\nAssemble # To compile the shellcode and get the object file we can use any assembler, I prefer nasm:\nnasm -f win64 pop_calc.asm -o pop_calc.o Get Payload bytes # This is not necessary to just compile and run the shellcode. But, assuming we want to use this as payload, this is the one-liner used to generate the instruction bytes\nfor i in $(objdump -D pop_calc.o | grep \u0026#34;^ \u0026#34; | cut -f2); do echo -n \u0026#34;\\x$i\u0026#34; ; done Link # Before running this shellcode as such we would requrire linking, which can be done by\nld -m i386pep pop_calc.o -o pop_calc.exe To Run # pop_calc.exe ","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/series1_pop_a_calc_part_2/","section":"Welcome to Posts!","summary":"Writing the Shellcode x64 # This part of the blog covers the 64 bit shellcode to pop a calculator.","title":"Popping a calculator - 64 bit - Part 2/3","type":"posts"},{"content":" Windows Shellcoding Series 1 - Part 1/3 # Popping a calculator # Init() # Now in the series I would be covering both the 64 bit and 32 bit versions of the shellcode to pop a calculator and would go about explaining them both separately.\nThe Approach # The basic idea of approach or the methodology in which I intend to approach writing this shellcode is the same for both 64 bit and 32 bit.\nNow let\u0026rsquo;s start by thinking backwards from the result as to figure out what we need in the shellcode to launch the calculator.\n- Execute a calculator # The end goal of our current shellcode is that it needs to end in launching a calculator For the exact purpose of executing/launching applications windows has the WinExec API which does exactly what we need\nsource : MSDN WinExec Documentation\nSo all we need to do is call WinExec with it\u0026rsquo;s required parameters and we\u0026rsquo;re done. We could have also done it using CreateProcessA but that involves a lot more arguments and I wanted to use the most simplest approach to this shellcode But, now this gets us thinking how do we go about calling WinExec?🤔\n- How to call WinExec? # If we are normally programming we can just do a WinExec() with the necessary arguments\nHowever, internally in assembly we do a call register where the register holds the addresss of the function that we are about to call\nSo in a nutshell, To call any function we need an address An address to where this function is defined and loaded in memory\nSo first we need to figure out where this WinExec Function is defined inside the system.\nNow upon basic googling we find kernel32.dll to contain the function definition of WinExec .\nSo now we need to go about finding where exactly inside kernel32 is this function Winexec defined\n- Finding WinExec inside kernel32 # So now to get down to a few Windows Reversing basics, All windows executables need to follow the PE format which defines how a particular executable is to organize it\u0026rsquo;s various data, like code, images, functions that it imports from other executables or libaries so on and so forth.\nSo, any windows executable (PE format) contains a lot of sections out of which two important ones are the Export Table and Import table\nThese two tables store the information relating to the modules that are being imported by the binary and exported from the binary\nIn our case we need to look for WinExec inside kernel32.dll under the Export Directory, because whatever is being exported out of a dll is stored under the Export Directory.\nThis Export directory would contain information like the name of the corresponding function (WinExec in our case) and the offset where we can find it\nSo summarising what we need to do now is\nto find the base address to the kernel32.dll function then from there we can get to the Export Address Directory inside kernel32.dll then next we can get to the base address of the function WinExec - Getting base of kernel32.dll # Windows creates/launches a thread to run any code, even the arbitrary bytes such as this shellcode. And while doing so, it also associates a very important data structure to each thread that it runs and controls called the TEB - The Thread Environment Block. This structure holds important information pertaining to a thread and the libraries/dlls it loads. This TEB also points to another important strcuture associated to any such process and thread called the PEB - Process Environment Block which is maintained at a constant offset from the TEB. Using this PEB now we can find the base address of the kernel32.dll\nNow this might be a bit confusing to the new ones here, the questions probably running through your mind is,\nSure, there\u0026rsquo;s a TEB associated to every running thread and running a thread is how windows runs the shellcode. But what I don\u0026rsquo;t get is,\nWhy is this associated to kernel32.dll which has nothing to do with the shellcode as of yet? Why is it already associated with our shellcode without us even having to load this particular library/dll? Why is it already associated without even having to call any function from it previously? Well to answer that, let\u0026rsquo;s take a step back and look at three important dlls in Windows that are crucial to the functioning of the Operating system by itself\nntdll.dll kernel32.dll KERNELBASE.dll These dlls contain a lot of functions that are crucial to the very basic functioning of the Operating system itself and is constantly being accessed by multiple user processes and even windows internal processes to keep the operating system functioning and alive. Windows\u0026rsquo;s own processes make use of various functions from these dlls to even start up the OS by itself. For example, The base services (like working with file systems, processes, devices, etc.) are provided by kernel32.dll.\nSo I hope the importance of these dlls in the Windows operating system established now.\nAnd because these dll\u0026rsquo;s are commonly used and loaded, it would make a lot more sense to just load them into the memory once at system start and then pass handles (or) pointers as reference to other processes which require functions from these dlls.\nWhich is exactly what happens and why it is already associated in a process\u0026rsquo;s TEB-\u0026gt;PEB by default.\nAnd because these dlls are very important they are by default imported by each and every thread/process because it is required to even start up the thread in the first place. Especially ntdll.dll and kernel32.dll\nTo summarise, we can find the kernel32.dll\u0026rsquo;s base through the TEB associated with our shellcode thread because it is already imported when the OS runs the shellcode.\nSo now we know where we can find these dll\u0026rsquo;s being loaded and under what data structure can we find them. The how is explained in this series.\n- Compiling and running the shellcode # Loading the shellcode can be done by the help of a simple dropper program which carries our payload (shellcode) and runs it on the fly. This method is covered in my other blog post which you can find here\nSo now that we have the approach down This is the final skeletal steps of our approach to write our shellcode\n1) Get the kernel base address\r2) Get the address to the Export table\r3) Find the Base address of the WinExec function\r4) Load the arguments into the WinExec function\r5) Call the function\r6) Compiling the shellcode These 6 steps are going to be out outline for the writing the shellcode\nWe\u0026rsquo;ll look into 64 bit shellcode in the next Part of this blog post.\n","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/series1_pop_a_calc_part_1/","section":"Welcome to Posts!","summary":"Windows Shellcoding Series 1 - Part 1/3 # Popping a calculator # Init() # Now in the series I would be covering both the 64 bit and 32 bit versions of the shellcode to pop a calculator and would go about explaining them both separately.","title":"Popping a calculator - Basic - Part 1/3","type":"posts"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/","section":"retr0ds_blog","summary":"","title":"retr0ds_blog","type":"page"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/categories/reversing/","section":"Categories","summary":"","title":"Reversing","type":"categories"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/series/","section":"Tags","summary":"","title":"Series","type":"tags"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/shellcode/","section":"Tags","summary":"","title":"Shellcode","type":"tags"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/series/shellcoding/","section":"Series","summary":"","title":"Shellcoding","type":"series"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/","section":"Welcome to Posts!","summary":"Learn more about me and why I am starting this blog.","title":"Shellcoding series","type":"posts"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Contains all my posts organized year wise\n","date":"27 March 2024","externalUrl":null,"permalink":"/posts/","section":"Welcome to Posts!","summary":"Learn more about me and why I am starting this blog.","title":"Welcome to Posts!","type":"posts"},{"content":"","date":"27 March 2024","externalUrl":null,"permalink":"/tags/windows/","section":"Tags","summary":"","title":"Windows","type":"tags"},{"content":" Windows Shellcoding Series 0 # Init() # Welcome to the prequel blogpost of my Shellcoding Series With this I intend to start of a series of Shellcoding based blogposts aiming to develop and post interesting shellcodes\nThe pre-requisite to follow this series of blog posts:\nA laptop ofc Bad social life (Why else would you be on here?) An omnitirix (Everyone has one these days) The Hardcover Windows internals book by Pavel Yosifovich 7th edition (to place your laptop on for good ergonomics) The Why? # I have always been fascinated by shellcode (especially in windows) and the intricacies it holds.\nStriving to create a nulbyte free shellcode, limiting the shellcode to under a certain size are some of the intricacies that we\u0026rsquo;ll get into as well\nThe idea of being able to use a set of bytes as a payload to inject into memory and to execute it has always seemed fun to me.\nSo I thought the best way to learn shellcoding is to make a blog series out of it as I experiment my way through shellcode and windows internals . And I hope to learn a lot out of this journey while being able to share to the community as well.\nWell, without further ado, let\u0026rsquo;s jump right into the topic!\nWhat is Shellcode? # Simply put, a piece of shellcode is a set of bytes(of assembly instructions) that can be loaded in memory and executed like any other piece of assembly code.\nA shellcode is a versatile piece of code that allows us to dynamically load a block of assembly instructions and execute it on the fly thereby enhancing the capabilities of a binary. It is particularly useful for malicious purposes, when combined with an encrypter or a packer it can go undetected under various EDRs and other AV scanners and checkers.\nFor example\nchar shellcode[] = \u0026#34;\\x90\\x90\\xcc\\xc3\u0026#34; \\x90 is for NOP \\xcc is for INT3 \\xc3 is for RET\nThis payload/shellode translates to\nNOP\rNOP\rINT3\rRET And this shellcode can be loaded into memory and executed like any other section of assembly code\nWe\u0026rsquo;ll be covering the loading of shellcode in the other blogposts of mine\nWhat does it accomplish? # Now clearly the above shown shellcode doesn\u0026rsquo;t accomplish much\nThere\u0026rsquo;s much more powerful and useful shellcode harboring malicious intent such as connecting to a c2 server and downloading the actual malicious file, dll injection, processs injection and many more.\nThere\u0026rsquo;s a pretty neat interface to get working shellcode for this purpose on windows\nMsfVenom # MsfVenom is a shellcode generator that has templates based upon which we can customize our own payload\nNow this series doesn\u0026rsquo;t cover shellcode generation by MsfVenom, Metasploit has a pretty neat documentation for that. Feel free to check that out.\nAbout this series # Now this series aims to showcase various shellcode/payload for various purposes on windows and aims to completely write it from scratch and in the process also learn a lot about Windows Internals, it\u0026rsquo;s structures, APIs and techniques\nThis series would mostly look like a walkthrough rather than a research blog, because it is being written as I am exploring around in windows internals and red teaming as well.\nExit() # With all that being said, now let\u0026rsquo;s get down to business and let\u0026rsquo;s write some basic windows shellcode begining with the next blog post.\n","date":"27 March 2024","externalUrl":null,"permalink":"/posts/shellcoding_series/series0_basic/","section":"Welcome to Posts!","summary":"Windows Shellcoding Series 0 # Init() # Welcome to the prequel blogpost of my Shellcoding Series With this I intend to start of a series of Shellcoding based blogposts aiming to develop and post interesting shellcodes","title":"Windows Shellcoding Series 0","type":"posts"},{"content":"","date":"24 March 2023","externalUrl":null,"permalink":"/tags/aes_cbc/","section":"Tags","summary":"","title":"AES_CBC","type":"tags"},{"content":"","date":"24 March 2023","externalUrl":null,"permalink":"/tags/htbca23/","section":"Tags","summary":"","title":"HTBCA23","type":"tags"},{"content":"","date":"24 March 2023","externalUrl":null,"permalink":"/tags/reversing/","section":"Tags","summary":"","title":"Reversing","type":"tags"},{"content":"tl;dr\nDynamically resolved hashed API Tls_call_back based anti-debug check AntiDebugFlag check implemented using ProcessInformationClass AES_CBC decryption of image to find flag Challenge points: No. of solves: Solved by: retr0ds || AmunRha Challenge Description # You finally manage to remotely connect to a computer onboard the alien vessel to shut down the defense mechanisms. However, it instantly starts acting up and ends up deploying malware as a defense mechanism. All your documents including your hard earned map of the vessel topology is now encrypted. And we are given two files\nChallenge.exe vessel_map.jpeg.owo So, on the base level, it ought to be malware that encrypts files Now we move on to figuring out how.\nTriaging: # Just running the binary inside a VM doesn\u0026rsquo;t seem to affect much inside the binary, nor is trying to pass it as an argument seem to make a difference.\nAnd trying pintools on the binary also seems to result in an error. Hmm, that\u0026rsquo;s odd, seems to have implemented an anti-debug check\nStatic Analysis: # It is UPX packed, so we go ahead and unpack it using upx -d challenge.exe\nNow, load it back again in IDA.\nFunctions: # main\nWe find main() fairly easily, given it\u0026rsquo;s not stripped\nsub_140001080 (AKA) GetFuncByHash Main first calls these functions with an integer value return values are in v4 and v5. And later v4 and v5 are called dynamically as functions. So it is safe for us to assume that this would be a GetFunctionByHash\nsub_1590 Unsure of what it does, we\u0026rsquo;ll keep it aside for now\nv4 and v5 functions The dynamically resolved functions are now called where unkn_array_1 is a byte_array of length 16. We hope to find this out later during the process of debugging to see what are the APIs being called\nsub_140001210 (AKA) Unkn_func_3 This function also employs GetFuncByHash() and calls another API, it is safe to assume v5 might be the return value. This in turn is being used as an argument in the next function call based on the function parameter a1 (a1 passed as v8 in main, is the variable used inside the API called by v5 and v4)\nWe\u0026rsquo;ll get to how and why I named the byte array unkn_16_byte in the next sub_function\nsub_140001290 (AKA) Encrypt_Func\nNow we get to the Function which seems to give us a basic idea of what exactly is being carried out in terms of encryption inside the binary.\nWe seem to check for this directory,\nand a bunch of operations(analyzed below) later we see below a set routine of syscalls OpenFile ReadFile CloseFileHandle\nSome function with two bytearray\u0026rsquo;s as args and v17, v18(the buffers from readfile)\nThen Writefile with v18,v17 as args CloseFileHandle\nSo it is safe to assume and form a HUNCH that,\nIt takes in Two buffers B1 (unkn_16_byte) and B2 (unkn_array_1) each 16 bytes in length Reads from File A Encrypts file_bytes using B1, and B2 under some Encryption Algorithm and stores it into a new file. Both of these B1 and B2 are 16 bytes long and they Also going by the strcpy(), a hunch can be that it stores the filename and is appended the \u0026ldquo;.owo\u0026rdquo; before writing to it. The current hunch is going to be that the encryption algorithm used is AES under CBC mode given it has a key as well as a\nDynamic Analysis # Current Objective:\nGet the debugging process up and running Attaching a debugger and stepping through results in an exception being thrown with error code 0x5 for MEMORY_ACCESS_VIOLATION inside ntdll. Now, that\u0026rsquo;s interesting!! So, the malware author implemented either an existing or a custom anti-debug check method/routine wherein the process can identify if it is being debugged before even it gets to the challenge file\u0026rsquo;s code/the start()\nSo, the program is started by the OS, and during the RT setup, some function checks if there is a presence of a debugger or not.\nNow we go back into the binary and search for \u0026ldquo;Debugger\u0026rdquo; inside functions we get nothing, next thought is to check for it in strings, and Lo and Behold! we are led to Tls_Callback_0\nSo googling about this we get to : Tls_Callback_0_Anti-Debug\nTLS callback is a function that is called before the process entry point executes.\rIf you run the executable with a debugger, the TLS callback will be executed before\rthe debugger breaks. You can see the TLS callback is called by the loader during\rprocess startup. So right now we just patch the assembly from a jz to jnz to let debuggers work through this\nAnd BOOM! now we can enter the user code of the binary.\nObjective : Get the debugging process up and running\nCurrent Objective: Figure out what APIs are being resolved by hashing\nIn main :\nv4() \u0026lt;\u0026mdash;\u0026ndash;\u0026gt; NtAllocateVirtualMemory v5() \u0026lt;\u0026mdash;\u0026ndash;\u0026gt; NtWriteVirtualMemory\nSo it creates a virtual memory space and writes the contents in unkn_array_1 into that memory space\nWe set a Hardware Breakpoint at this place just in case In sub_1210 (AKA) Unkn_func_3 :\nv3() \u0026lt;\u0026mdash;-\u0026gt; NtQueryInformationProcess\nObjective down: Figure out what APIs are being resolved by hashing\nFunction specific reversing: # sub_1590 # Upon debugging we see this function achieves nothing nor does return anything useful under any register, it copies the buffer, runs a while loop for 0x1600 times, set the variable result to that value and returns result.\nsub_140001210 (AKA) Unkn_func_3 # Stepping into this, we found out the API being called is NTQueryInformationProcess, and it returns v5.\nSo we pull up NtQueryInformationProcess\u0026rsquo;s MSDN\nI have a suspicion that this might involve some form of tomfoolery with the PEB structure or ProcessInformationClass given a constant value has been passed on as the second argument\nThe next step was to google and confirm our hunch,\nSearch as such, gives us what we need right in the first link Anti-Debug-Checks\nSo the third argument (ie) v5 is dwProcessDebugFlags, and, if the process is being debugged it would be set to 0, and if not 1\nWith that in mind, we now move on to the next function call inside the binary,\nNow this function is being called by using the first argument as the function pointer, and a1 happens to be the unkn_16_byte (which I assume is either the key or IV), and the second argument is the dwProcessDebugFlag\ndwProcessDebugFlag is 0 if being debugged\ris 1 if not being debugged Now, we know the calling convention of windows functions\nSo we manually change the EDX register value to 1 and continue execution by hitting f7\nnow converting it all to code,\nwe see it makes use of xmmwords (128-bit registers) to do some operations\nWe are unsure of such opcodes, but our goal rn is to retrieve the unkn_16_byte array as if the program was never debugged.\nAnd we seem to easily accomplish that by just passing through the instructions and finally examining the RCX value before the return.\nWe get the unkn_16_byte array to be 6D597133733676397924422645294840\nsub_1290 (AKA) EncryptFunc # This function seems to get the HANDLE to the first file under \u0026ldquo;C:\\Users\\Administrator\\Documents\\\u0026rdquo;\nThen it goes onto this part of the code The above snippet is responsible for just copying over the file path string from the buffer to the variables. Unimportant.\nThis above part of the code is responsible for converting the filename to UTF-8 from UTF-16(Microsoft/Windows stores text in the form of UTF-16 to ensure broader encompassing of symbols/characters, this is AKA wide char where each character is given a set space of 2 bytes,in the event only a single byte is used, the unused byte is nulled out)\nThen the UTF-8 converted text is put in the routine of\nOPEN\rREAD\rCLOSE\r\u0026lt;ENCRYPT\u0026gt;\rOPEN\rWRITE\rCLOSE The Core # And now we get to the core of the binary This encrypt function determines the entire functionality purpose of the binary\nBefore going into the function, we see it takes in the unkn_16_byte we retrieved and another array with just the null bytes(chances for it being the IV incase this is AES)\nNow we step into the function, by hitting f7 we get bytes, we continue hitting c to convert it to code and p to define it as a function in IDA\nOnce we are a couple of functions in, we notice\nChecking out the byte array,\nWe see it is exactly the S-box used in AES.\nNow we have confirmed the encryption algorithm being used as well by taking a step-by-step approach.\nAll we have left is to decrypt the given .owo file and that should give us the FLAG\nThe Script # from Crypto.Cipher import AES f1 = open(\u0026#34;flag.png\u0026#34;,\u0026#34;wb\u0026#34;) x = AES.new((key=b\u0026#39;mYq3s6v9y$B\u0026amp;E)H@\u0026#39;, mode=AES.MODE_CBC, iv=b\u0026#39;\\x00\u0026#39;*16) f2 = open(\u0026#34;vessel_map.jpeg.owo\u0026#34;, \u0026#34;rb\u0026#34;) bytes = f2.read() f1.write(x.decrypt(bytes)) key = b'mYq3s6v9y$B\u0026amp;E)H@' is our unkn_16_byte in bytes format iv = 16 null bytes (ie) \u0026lsquo;\\x00\u0026rsquo; * 16\nOR\nWe can use CyberChef To retrieve the flag file\nThe Flag # HTB{573pp1ng_1n70_und0cum3n73d_4113n_4p15}\n","date":"24 March 2023","externalUrl":null,"permalink":"/posts/vessel_cartographer_htb2023/","section":"Welcome to Posts!","summary":"\u003cp\u003e\u003cstrong\u003etl;dr\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDynamically resolved hashed API\u003c/li\u003e\n\u003cli\u003eTls_call_back based anti-debug check\u003c/li\u003e\n\u003cli\u003eAntiDebugFlag check implemented using ProcessInformationClass\u003c/li\u003e\n\u003cli\u003eAES_CBC decryption of image  to find flag\u003c/li\u003e\n\u003c/ul\u003e","title":"Vessel Cartographer HTBCTF23","type":"posts"},{"content":"","date":"24 March 2023","externalUrl":null,"permalink":"/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":"","date":"19 February 2022","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":" Week 1(13th Feb 2022-18th Feb 2022) # Started with android reversing, went through few writeups and videos. Attempted to solve hayyim ctf 2022 breakable.apk, failed to fathom the code, so started off with solving droids-series from pico ctf\nNew Tools learned # d2j-dex2jar-to convert the apk to its java archive d2j-dex2jar filename.apk -o filename.jar\napktool-to extract the resources and the smali code apktool d filename.apk -o foldername\njd-gui-to view the graphical disassembly of the jar file jd-gui filename.jar\nAlso used android studio to emulate the apk\nChallenges solved # picoCTF # droids0-involved looking at the event log in android studio and ctrl+f for \u0026ldquo;pico\u0026rdquo; droids1-involved finding the if condition ,taking the resource number used in .get() to find the pasword, we see is stored in \u0026ldquo;password\u0026rdquo; string, looking under \u0026ldquo;password\u0026rdquo; in strings.xml \u0026hellip;\u0026ldquo;opossum\u0026rdquo; gets us the flag droids2-involved assembling pieces of a string stored as an array in a particular order(\u0026ldquo;dismass.ogg.weatherwax.aching.nitt.garlick\u0026rdquo;) to get flag Week 2(20th Feb 2022-25th Feb 2022) # Continued with last week\u0026rsquo;s learning and started with understanding hwo to patch a apk.For this I looked into droids3 and droids4 from pico ctf.\nNew Tools learned # keytool - Generate a new key to sign the build keytool -genkeypair -v -keystore key.keystore -alias publishingdoc -keyalg RSA -keysize 2048 -validity 10000 jarsigner - to sign the apk after patching it jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore ./key.keystore \u0026lt;path to apk\u0026gt;.apk publishingdoc Challenges solved # picoCTF # droids3-involved patching the smali code from moving to \u0026ldquo;nope\u0026rdquo; function to \u0026ldquo;yep\u0026rdquo; function for any input given droids4- ","date":"19 February 2022","externalUrl":null,"permalink":"/posts/android_reversing_basic/","section":"Welcome to Posts!","summary":"This covers basic android reversing that I did in my freshman year","title":"Android Reversing - Basic Setup","type":"posts"},{"content":"","date":"19 February 2022","externalUrl":null,"permalink":"/tags/picoctf/","section":"Tags","summary":"","title":"PicoCTF","type":"tags"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/about/","section":"Welcome to About!","summary":"Learn more about me and why I am starting this blog.","title":"Welcome to About!","type":"about"}]